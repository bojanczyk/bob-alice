\section{Infinite alphabets}
\label{sec:infinite-alphabets}


In this section, we present a variant of our model which deals with an input alphabet. This direction is rooted in the tradition of language theory for infinite alphabets, which dates back to the work of Kaminski and Francez~\cite{kaminskiFiniteMemoryAutomata1994}, and has been developed in many subsequent papers, see e.g.~the survey~\cite{bojanczykOrbitFiniteSetsTheir2017}. The general idea is that we have an infinite alphabet $\atoms$ (whose elements are called atoms), and the languages that we care about refer only to equality between letters, as in the following examples
\begin{align}
\setbuild{ w \in \atoms^*}{the first letter is equal to the last letter}
\label{eq:first-last}
\\
\setbuild{ w \in \atoms^*}{some letter appears at least twice}
\label{eq:some-twice}
\end{align}
There are numerous models of automata for such languages, which typically involve some kind of finite memory and registers that store letters from $\atoms$. For example, the language~\eqref{eq:first-last} is recognised by an automaton which loads the first letter into a register, and then toggles acceptance depending on comparison of the register with the current input letter. On the other hand, the language~\eqref{eq:some-twice} is recognised by an automaton which nondeterministically guesses a position, puts its letter into a register, and then waits for this letter to appear again. 

Numerous models for infinite alphabets have been proposed in the literature, such as deterministic and nondeterministic automata with registers~\cite[Section 2]{kaminskiFiniteMemoryAutomata1994}, two-way variants of these~\cite[Definition 2.1]{nevenFiniteStateMachines2004}, unambiguous register automata~\cite[Section 5]{colcombet2015unambiguity}, single-use register automata~\cite[Definition 3]{bojanczykstefanski2020}, alternating automata with registers~\cite[Section 2.5]{DBLP:journals/tocl/DemriL09}, data automata~\cite[Section 4.2]{bojanczykTwovariableLogicData2011}, or various kinds of regular expressions~\cite{regexpKaminskiTan2004,regexpLibkin2015,KleeneNominal2019} --- see Figure~\ref{fig:automata-infinite-alphabets} for a survey. Interestingly, all of those models are pairwise non-equivalent. This sharply contrasts with the finite-alphabet case, where virtually all models capture the regular languages.
%  One attempt to put order into the chaotic zoo of automata models for infinite alphabets is the theory of orbit-finite sets~\cite{bojanczyk_slightly}, which builds on the ideas of nominal sets~\cite{PittsAM:nomsns}. 

In this section, we describe an infinite-alphabet version of our two-party protocols.
The motivation for this study is twofold: (a) a search for a canonical model of regular languages for infinite alphabets; and (b) mathematical interest. Regarding the point (a), we hope that the adaptability of two-party protocols to various settings will help us  find a canonical model of regular languages for infinite alphabets. This seems to be at least partially successful, since there is evidence --- which we present in this section --- that the protocols are equivalent to an existing automaton models, namely the unambiguous register automaton. If true, this equivalence would be unexpected, since there does not seem to be any syntactic connection between the two models. Regarding point (b), one of the exciting features of our protocol model for infinite alphabets is that the interaction between the two parties becomes essential, and the protocol cannot be reduced to the one-round case as in \cref{lemma:one-round-reduction-general}.

\begin{figure}
    \begin{enumerate}
    \item deterministic register automata~\cite[Definition 3]{kaminskiFiniteMemoryAutomata1994}
    \item nondeterministic register automata~\cite[Definition 1]{kaminskiFiniteMemoryAutomata1994}
    \item nondeterministic register automata with guessing~\cite[Definition 2.7]{bojanczyk_slightly}
    \item weighted register automata over the two-element field~\cite[Definition 3.1]{orbitFiniteVectorTheoretics}
    \item two-way deterministic register automata~\cite[Definition 5]{kaminskiFiniteMemoryAutomata1994}
    \item two-way nondeterministic register automata~\cite[Definition 2.1]{nevenFiniteStateMachines2004}
    \item alternating register automata~\cite[p.~16:8]{lazicDemri09}
    \item alternating register automata with one register~\cite[p.~16:19]{lazicDemri09}
    \item unambiguous register automata~\cite[Section 5]{colcombet2015unambiguity}
    \item register automata with pebbles~\cite[Section 2.2]{nevenFiniteStateMachines2004}
    \item \label{it:single-use} single-use register automata~\cite[Definition 2]{bojanczykstefanski2020}
    \item data automata~\cite[Section 4.2]{bojanczykTwovariableLogicData2011}
    \item class automata~\cite[Section III]{bojanczykExtensionDataAutomata2010} 
    \item regular expressions~\cite[Definition 2]{regexpKaminskiTan2004}
    \item three other kinds of regular expressions~\cite[Sections 4, 5, 6]{regexpLibkin2015}
    \item yet another kind of regular expressions~\cite[Section 5]{KleeneNominal2019}
    \item monadic second-order logic with equality~\cite[Section 2.4]{nevenFiniteStateMachines2004}
    % \item session automata
\end{enumerate}
    \caption{A non-exhaustive list of models of automata for infinite alphabets. All models in the list are pairwise non-equivalent. In contrast, for finite alphabets, all models in this list are equivalent, and define exactly the regular languages. }
    \label{fig:automata-infinite-alphabets}
\end{figure}




% . Regarding the point (b), we note that the theory of automata for infinite alphabets is closely related to the theory of orbit-finite sets~\cite{bojanczyk_slightly}, which builds on the ideas of nominal sets~\cite{PittsAM:nomsns}. This theory has many interesting mathematical aspects, and we hope that our model will be useful in this context.



\subsubsection{Protocols for an infinite alphabet}
\label{sec:protocols-infinite-alphabet}
We now give a more detailed description of our model. We start by explaining formally, what it means that the
language can only refer to equality between letters. Following the literature on nominal and orbit-finite sets, this is formalised by requiring that the language is invariant under permutations of the alphabet, as described in the following definition.

\begin{definition}[Equivariant language] \label{def:equivariant-language}
    A language $L \subseteq \atoms^*$ is called \emph{equivariant} if 
    \begin{align*}
    w \in L \quad \iff \quad \pi(w) \in L
    \end{align*}
    holds for every permutation $\pi$ of the alphabet $\atoms$.
\end{definition}

Examples of equivariant languages include the languages in~\eqref{eq:first-last} and~\eqref{eq:some-twice}. On the other hand, the language ``the first letter is a vowel'' or ``the letters are strictly increasing'' are not equivariant, since there is no such thing as a vowel, or an ordering of the letters. The principle of equivariance will also be applied to protocols, as described below, by restricting the two parties to use only equivariant strategies.





The idea is to use the same kind of protocol as in Definition \ref{def:two-party-protocol-boolean}, except that apart from bits, the parties can also send letters from the alphabet $\atoms$. It follows that the allowed set of messages is 
$\set{0,1} + \atoms$, i.e.~the disjoint union of the Booleans and the input alphabet. Similarly, to Definition~\ref{def:two-party-protocol-boolean}, the number of rounds is a fixed number $k$ and in the $i$-th round each party chooses 
a new message according a strategy which is a function of the following type: 

\begin{align*}
\myunderbrace{\atoms^*}{local \\ string} \times \myunderbrace{(\set{0,1} + \atoms)^{i-1}}{messages received \\ in previous rounds} 
\to
\myunderbrace{\set{0,1} + \atoms}{message sent \\ in this round}
\end{align*}
In the last round, Bob must send a bit, and this bit is the output of the protocol.
An important restriction of the protocol is that the strategies of both parties must be \emph{equivariant} in the following sense: 
a strategy $\sigma$ is equivariant if for every permutation $\pi$ of $\atoms$ and for every $i$, it satisfies the following condition:
\begin{align*}
\sigma(w, m_1, \ldots, m_{i-1}) = m_i 
\quad \Rightarrow \quad
\sigma(\pi(w), \pi(m_1), \ldots, \pi(m_{i-1})) = \pi(m_i).
\end{align*}
In the above, $\pi$ is applied to messages in the natural way -- it modifes the atoms and leaves bits unchanged.

\begin{myexample}[Repetitions cannot be detected]
    Let us formalise the claim from Example \ref{ex:some-twice} that the language ``some letter appears at least twice'' cannot be computed by a protocol. Suppose, towards a contradiction, that there is a protocol with $k$ rounds that computes this language. Consider an input string with $2k+2$ pairwise different letters, split in a way that Alice and Bob get $k+1$ letters each. In the execution of the protocol there are at most $k$ atoms which are sent as messages. In particular, there must be some atom $a$ that appears in Alice's part of the input string, but is not sent as a message, and similarly there must be some atom $b$ that appears in Bob's part of the input string, but is not sent as a message. Consider an atom permutation $\pi$ which swaps $a$ with $b$. If we apply this atom permutation to Alice's part of the string (but not Bob's), then the communication history will remain unchanged. In particular, the output of the protocol will be the same on both inputs. However, after applying this permutation, the input string has a repetition, unlike the original one. 
\end{myexample}


\subsubsection{Orbit-finite sets}
\label{sec:orbit-finite-sets}
In this section, we do a more systematic analysis of automata models for infinite alphabets, and their relationship to our protocols. As an organising principle, we use the approach of~\cite{bojanczykOrbitFiniteSetsTheir2017}, which defines a generalization of finite sets
suitable for infinite alphabets, called orbit-finite sets. Using this notion, we can lift any model of computation that uses finite sets, to a model that uses orbit-finite sets, which allows us for a clean comparison of the two setting.
%  To simplify the exposition, instead of the fully general notion of orbit-finite sets, we use a special case, which is called \emph{polynomial orbit-finite sets}. This special case has a more concrete defnition, and is sufficient for our purposes. 
\begin{definition}[Orbit-finite sets] \label{def:orbit-finite-sets}
    An orbit-finite set\footnote{
This definition is weaker than the usual notion of orbit-finite sets~\cite[Section 5]{bojanczyk_slightly}; in fact it is the special case of the usual notion that is called \emph{polynomial orbit-finite sets} in~\cite[Section 1]{bojanczyk_slightly}.
The usual notion  allows for two extra features: (a) restricting to equivariant subsets (e.g.~one could limit $\atoms^2$ to pairs which are non-repeating); and (b)  symmetries (e.g.~one could identify pairs in $\atoms^2$ if they agree up to swapping of coordinates, thus yielding unordered pairs). In some cases, the extra features are desirable, in particular they establish a connection with set theory~\cite{blassDedekind2016} and  nominal sets~\cite[Section 5]{PittsAM:nomsns}. However, they do not play any role in the analysis of protocols and automata and, to avoid some technicalities, we use the simpler polynomial version. This simplification is purely technical --- all results would continue to hold for the usual notion of orbit-finite sets.
} is any set of the form 
    \begin{align*}
    \atoms^{d_1} + \cdots + \atoms^{d_n},
    \end{align*}
    for some natural numbers $d_1,\ldots,d_n \in \set{0,1,\ldots}$. 
\end{definition}

The special case of $\atoms^0$ describes a set with exactly one element, namely the empty tuple. Therefore, orbit-finite sets generalise finite sets, since a  finite set with $n$ elements can be seen as the orbit-finite set which has $n$ disjoint copies of $\atoms^0$. We will only be interested in properties that are equivariant, i.e.~invariant under permutations of the atoms, in the following sense:
\begin{align*}
\myunderbrace{x \in X \iff \pi(x) \in X}{equivariant subset $X$ \\ of an orbit-finite set}
\qquad 
\myunderbrace{f(x) = y \iff f(\pi(x)) = \pi(y)}{equivariant function $f$ \\ between two orbit-finite sets}
\end{align*}
We can now discuss various orbit-finite models of computation, by generalising finite sets to orbit-finite ones, and requiring all subsets and relations to be equivariant. As a first example of this approach, we can revisit the definition of Boolean protocols from Section~\ref{sec:protocols-infinite-alphabet}, and define it in terms of orbit-finite sets:

\begin{definition}[Orbit-finite protocol]
    \label{def:orbit-finite-protocol}
  An orbit-finite Boolean two-party protocol  is defined in the same way as in Definition \ref{def:two-party-protocol-boolean}, except that:
  \begin{enumerate}
    \item the input alphabet $\Sigma$, and the message spaces $Q_A$ and $Q_B$ are orbit-finite; and 
    \item the strategies of both players and the output function are equivariant.
  \end{enumerate}
\end{definition}

Indeed, the description from Section~\ref{sec:protocols-infinite-alphabet} is  the special case of the above definition where the input alphabet is $\atoms$, and the message spaces are both equal to 
\begin{align*}
\myunderbrace{\atoms}{letter} + \myunderbrace{\atoms^0}{bit 0} + \myunderbrace{\atoms^0}{bit 1}.
\end{align*}
On the other hand, the special case is also equivalent to the general case, since an element of a general orbit-finite set can be
transmitted using a constant number of bits and atoms (by first sending the index of the summand, and then sending the tuple of atoms).
It follows that the protocols from Definition~\ref{def:orbit-finite-protocol} and those from Section~\ref{sec:protocols-infinite-alphabet} have the same expressive power. From now on we will use the formalisation from Definition~\ref{def:orbit-finite-protocol}.

Orbit-finiteness can also be used to define automata. The following definition has the same expressive power as the standard (nondeterministic and deterministic) register automata for infinite alphabets from~\cite{kaminskiFiniteMemoryAutomata1994}; this equivalence was shown in~\cite[Lemma 6.3]{bojanczykAutomataTheoryNominal2014} and is one of the original motivations for studying orbit-finiteness.

\begin{definition}
    [Orbit-finite automata]
    \label{def:orbit-finite-automata}
    A nondeterministic orbit-finite automaton is defined in the same way as a nondeterministic finite automaton, except that all sets are orbit-finite, and all subsets and functions are equivariant: 
\begin{align*}
    \myoverbrace{
        \myunderbrace{Q}{states} \quad 
        \myunderbrace{\Sigma}{input \\ alphabet}
    }
    {orbit-finite}
    \qquad
    \myoverbrace{
        \myunderbrace{I \subseteq Q}{initial \\ states} \quad 
        \myunderbrace{F \subseteq Q}{final \\ states} \quad 
        \myunderbrace{\Delta \subseteq Q \times \Sigma \times Q}{transitions}
    }{equivariant}.
\end{align*}
A deterministic orbit-finite automaton is the special case which has exactly one initial state, and where the transition relation is a function.
\end{definition}

As stated in Figure~\ref{fig:automata-infinite-alphabets}, deterministic and nondeterministic orbit-finite automata have different expressive power. Moreover, none of these models is equivalent to orbit-finite protocols: deterministic automata are too weak, and nondeterministic automata are too strong:

\begin{myexample}
    [Deterministic too weak]\label{ex:protocol-not-dofa}
     Every deterministic orbit-finite automaton can be simulated by a protocol, in the same way as for finite alphabets. Alice sends her state to Bob, which will typically require sending some atoms. Bob then uses this state to continue the computation and report the answer. 
    
    However, the inclusion is strict: protocols are more powerful than deterministic orbit-finite automata. One reason is that protocols are symmetric, -- if a language can be computed by a protocol, then so can its reverse. On the other hand, deterministic orbit-finite automata are not symmetric. For example, the language ``the first letter appears at least twice'' can be recognised by a deterministic orbit-finite automaton, but its reverse ``the last letter appears at least twice'' cannot. The latter language can be computed by a protocol, and hence witnesses that the two models are different. 
\end{myexample}

\begin{myexample}
    [Nondeterministic too strong] \label{ex:protocol-not-nofa}  
    The language ``some letter appears at least twice'', from Example \ref{ex:some-twice}, can be recognised by a nondeterministic orbit-finite automaton, but cannot be computed by a protocol. We do not know yet if nondeterministic orbit-finite can simulate all protocols, and therefore for all we know the two models could be incomparable. However, as we will explain later in this section, we conjecture that there is indeed an inclusion, since we believe that protocols are equivalent to a special case of nondeterministic orbit-finite automata -- see Conjecture~\ref{conj:protocols-unambiguous}.
\end{myexample}

In Definition~\ref{def:orbit-finite-automata}, we have defined one-way orbit-finite automata, which read the input string from left to right. A natural extension are the two-way automata, which can move their reading head in both directions according to their transition
function. However, in the orbit-finite setting, two-way automata are very strong:

\begin{myexample}[Two-way too strong]\label{ex:protocol-not-2dofa}
    The language ``some letter appears at least twice'' can also be recognised by a deterministic two-way orbit-finite automaton~\cite[Example 18]{bojanczyk_slightly}. Therefore, this automaton model cannot be simulated by protocols.

    The reason why two-way orbit-finite automata are so strong is that they can make an unbounded number of visits to any given position -- for example the automaton that checks if some letter appears at least will visit the last position a linear number of times
    (the length of its run is quadratic). One idea to tame this power is to consider the bounded-crossing variant of two-way automaton, 
    which has a fix bound $k$ on the number of times that the automaton can visit a position \cite[p.~92]{neven2003power}.
    We believe that this model can actually be equivalent to the protocols. However, in our conjecture, we will focus on the 
    better studied model presented in the following section.
\end{myexample}

\subsection{Unambiguous orbit-finite automata}
\label{sec:unambiguous-orbit-finite-automata}
As we have shown in Examples~\ref{ex:protocol-not-dofa}, \ref{ex:protocol-not-nofa} and \ref{ex:protocol-not-2dofa}, protocols are not equivalent to one-way deterministic or nondeterministic orbit-finite automata, or their two-way variants automata. So what is the right automaton model?  We conjecture that the answer is  \emph{unambiguous orbit-finite automata}, i.e.~the special case of nondeterministic orbit-finite automata that have zero or one accepting runs for every input string.

\begin{conjecture}
    \label{conj:protocols-unambiguous} A language over an orbit-finite alphabet is computed by an orbit-finite protocol if and only if it is recognised by an unambiguous orbit-finite automaton.
\end{conjecture}

One corollary of this conjecture would be that unambiguous orbit-finite automata are closed under complement, since protocols can be complemented by flipping the output bit. This corollary has been conjectured in~\cite[p.9]{colcombet2012forms}, and to the best of our knowledge remains open, despite claims to the contrary in~\cite[Footnote 5]{colcombet2015unambiguity}.

In this section, we prove implication $\impliedby$ in the conjecture, i.e.~we show that orbit-finite protocols can simulate  unambiguous orbit-finite automata. Unlike similar results earlier in this paper, this simulation is non-trivial. Also, despite the one-way nature of the automata, the simulation crucially depends on the interactive nature of protocols, i.e.~it requires more than one round of communication. In particular multi-rounds protocols cannot be reduced to one round, as was the case for finite alphabets
(i.e.~\cref{lemma:one-round-reduction-general} is no longer true for the orbit-finite case).

\begin{theorem}
    \label{thm:unambiguous-to-protocol}
    If a language $L$ over an orbit-finite alphabet is recognised by an unambiguous orbit-finite automaton, then it is also computed by an orbit-finite protocol.
\end{theorem}
\begin{proof}
For the rest of this proof fix an unambiguous orbit-finite automaton, whose state space is the orbit-finite set $Q$.
Suppose that the input string is factorized as $w = w_1 w_2$. The general idea of the protocol is that Alice and Bob will jointly
compute the intermediate state, i.e.~the state $q$ which satisfies:
\begin{align*}
\myunderbrace{I \xrightarrow{w_1}q}{there is a run over $w_1$\\ from an initial state to $q$} \qquad \text{and} \qquad
\myunderbrace{q \xrightarrow{w_2} F}{there is a run over $w_2$\\ from $q$ to a final state.}
\end{align*}
By unambiguity, there is at most one intermediate state, and it exists if and only if the string is accepted.

Observe that Alice can compute
the set of states that are reachable from an initial state by reading $w_1$, and Bob can compute the set of states from which a final state is reachable by reading $w_2$. 
So, the challenge is to compute their intersection, which is either a singleton with the intermediate state, or the empty set. Before, we explain how to do this,
let us first explain why this is non-trivial, i.e. why Alice cannot send her set to Bob, or vice versa. The problem is that the set of all reachable subsets of $Q$ is not-orbit finite.
For example, if we consider the automaton for the language ``the last letter appears at least twice'' that non-deterministically guesses the penultimate appearance of the last letter, 
then the set of all reachable states after reading $w_1$ contains all the atoms that appear in $w_1$, which is unbounded (as it can grow with the length of $w_1$). It follows
that the set of all reachable subsets of $Q$ is orbit-infinite\footnote{
This observation can be summarized by saying that orbit-finiteness
is not preserved by the powerset construction. Is one of the main obstacles when working with orbit-finite sets. For example, it is the reason why nondeterministic orbit-finite automata are more powerful than deterministic ones.}
Instead, to determine their common state, will narrow down the set of possible candidates, by storing a list of possible orbits:
\begin{definition}[Orbit] \label{def:orbit}
    For a finite set $S \subseteq \atoms$, the $S$-orbit of $q \in Q$ is the following set:
    \begin{align*}
    \setbuild{ \pi(q)}{$\pi$ is a permutation of $\atoms$ such that $\pi(a)=a$ for all $a \in S$}.
    \end{align*}
The set $S$ is called the \emph{support} of the orbit.
\end{definition}

\begin{myexample}\label{ex:tau-disjoint}
    Let $Q = \atoms^5$, and consider the $\set{\text{{John}, {Eve}}}$-orbit of the following tuple
    \begin{center}
        (\red{John}, Tom, Mary, Tom, \red{Eve})
    \end{center}
    An element of this orbit is any tuple of the form 
    \begin{center}
        (\red{John}, $a$, $b$, $a$, \red{Eve})
    \end{center}
    where $a$ and $b$ are distinct atoms, which are not \red{John} or \red{Eve}. 
    % Two elements of this orbit are $\tau$-disjoint if the corresponding choices $\set{a_1,b_1}$ and $\set{a_2,b_2}$ are disjoint sets. 
\end{myexample}

 As the support increases, the orbit becomes smaller; in particular the biggest orbits are the ones with empty support, i.e.
 the $\emptyset$-orbits, or the equivariant orbits. It is not hard to see that every orbit-finite set has a finite number of equivariant orbits~\cite[Lemma 1.4]{bojanczyk_slightly}; in fact this is the reason for the name.  
Each orbit in an orbit-finite set is a subset of $\atoms^d$ for some $d$. In such an orbit, we partition the coordinates $\set{1,\ldots,d}$ into two parts: the \emph{fixed coordinates}, which used the atoms from the support, and the \emph{free coordinates}, which do not use these atoms. In Example~\ref{ex:tau-disjoint}, the fixed coordinates are  the first and last ones, while the free coordinates are the middle three. The \emph{dimension} of an orbit is the number of distinct atoms in the free coordinates. In Example~\ref{ex:tau-disjoint}, the dimension is two, corresponding to the atoms $a$ and $b$. 
An important special case is then the dimension is zero; in this case the orbit contains only one state.

In the protocol, Alice and Bob will jointly maintain a set $S \subseteq \atoms$ and list of $S$-orbits which may contain the intermediate state (starting with $S = \emptyset$ the list of all $\emptyset$-orbits).
The goal is to decrease the dimension of these orbits until they become zero-dimensional, by gradually computing the set $S$ of atoms that appear in the intermediate state. Once their orbits become zero-dimensional, they will contain only a finite (and bounded) number of the candidates
for the intermediate states. At this point, Alice can compute which of these candidates are reachable from an initial state over $w_1$ and send this (bounded) information to Bob, who can then check if one of these candidates can reach a final state over $w_2$. To decrease the dimension and increase $S$, we will use the following lemma.
\begin{lemma}\label{lem:fixed-atoms}
        Let $S \subset \atoms$ be a finite set, and let $\varphi \subseteq Q$ be an infinite $S$-orbit 
        of dimension $k$. 
        Consider an input string $w = w_1 w_2$, and the sets:
        \begin{align*}
        X_1 = \setbuild{ q \in \varphi}{$ I \xrightarrow{w_1} q$}
        \qquad
        X_2 = \setbuild{ q \in \varphi}{$ q \xrightarrow{w_2} F$}.
        \end{align*}
        There is a set $T \subseteq \atoms$ of size at most $k$, such that either: 
\begin{enumerate}
    \item   every state from $X_1$ contains an atom of $T$ on some free coordinate; or 
    \item   every state from $X_2$ contains an atom of $T$ on some free coordinate.
\end{enumerate}
    \end{lemma}
    \begin{proof}
 In the proof of the lemma, we use an analysis of disjointness, which is inspired by the sunflower lemma.
 We say that two states $p,q$ in an  $S$-orbit are $S$-disjoint if the intersection of atoms that appear in $p$ and $q$ is contained in $S$.
 For example, if we take the $\{\textrm{John}, \textrm{Eve}\}$-orbit from Example~\ref{ex:tau-disjoint}, then the two states
\begin{center}
    (\red{John}, Tom, Mary, Tom, \red{Eve}) \qquad
    (\red{John}, Ann, Timmy, Ann, \red{Eve})
\end{center}
are $\{\textrm{John}, \textrm{Eve}\}$-disjoint, because the sets $\set{\text{Tom, Mary}}$ and $\set{\text{Ann, Timmy}}$ are disjoint. In other words, the atoms from $S$ can repeat (in fact, they must),
but all other atoms must be disjoint in the two states.

The following claim characterizes subsets of orbits that do not contain any pair of disjoint elements:
\begin{claim}\label{claim:sunflower}
        Let $Q$ be a $S$-orbit type of dimension $d$ and let $X$ be a subset of $Q$.
        If $X$ does not contain two $S$-disjoint elements, then there is a
        set $T$ of at most $d$ atoms such that every element of $X$ uses at last one atom from $T$ on a free coordinate.
\end{claim}
\begin{proof}
        Take some element $x \in X$. Either there is an element of $X$ that is completely disjoint with $x$, or otherwise some atom from $x$ must appear in every other element of $X$ on a free coordinate.
\end{proof}

The claim leaves us with showing that at least one of $X_1$ or $X_2$ does not contain an $S$-disjoint pair of elements.
Suppose, towards a contradiction that both $X_1$ and $X_2$ contain $S$-disjoint pairs of elements, 
say $p_1, p_2 \in X_1$ and $q_1, q_2 \in X_2$. It follows that the two pairs $(p_1,p_2)$ and $(q_1,q_2)$ are
in the same equivariant orbit (of $Q \times Q$), i.e. there is some atom permutation $\pi$ which sends $p_1$ to $q_1$ and $p_2$ to $q_2$.
Applying $\pi$ to Alices's part of the input string, we obtain a new input string $\pi(w_1) w_2$, 
in which both $q_1$ and $q_2$ are valid intermediate states. It follows that
there are at least two accepting runs (one that passes trough $q_1$ and one that passes trough $q_2$),
contradicting the unambiguity assumption. 
\end{proof}

Using the above lemma, we will construct a protocol that simulates the automaton. As explained before, the idea is to narrow down orbit which contains the intermediate state. This idea is formalised in the following lemma. 


\begin{lemma}\label{lem:narrow-down-orbit}
    Let $S$ be a finite subset of atoms, and let $X \subseteq Q$ be an orbit. Alice and Bob can exchange a constant number of messages -- which depends only on the dimension of $X$ -- to determine if the intermediate state belongs to $X$. 
\end{lemma}

Before proving the lemma, let us explain how to use it to complete the proof of \cref{thm:unambiguous-to-protocol}.
We know that the set of all states $Q$ splits into constant number of equivariant orbits, so the two
parties can run the protocol the lemma for each of these orbits with $S=\emptyset$.
Each run of the protocol uses a constant number of rounds, so the total number of rounds is also constant.
It remains to prove the lemma.

\begin{proof}[Proof of \cref{lem:narrow-down-orbit}]
    The proof proceeds by induction on the dimension of the orbit $X$.
    
    The induction basis is when the  dimension is zero. In this case, the orbit has exactly one state, and Alice and Bob can simply check  if the state is reachable on their side and exchange this bit of information.

    Consider now the induction step. Apply \cref{lem:fixed-atoms}, to the orbit. In the factorisation $w = w_1 w_2$, at least one of the two alternatives in the conclusion of \cref{lem:fixed-atoms} must hold. Alice can check if the first alternative holds, and Bob can check if the second alternative holds.  At least one of the two parties must report success, which is witnessed by some set $T$ of atoms. The successful party sends the set $T$ to the other party. This is possible since the size of $T$ is bounded by the dimension of $X$. The orbit $X$ splits into finitely many orbits $X_1,\ldots,X_n$ with the larger support $S \cup T$, see~\cite[Lemma 10.9]{bojanczyk_slightly}. The number $n$ depends only on the dimension of $X$ (as the size of $T$ is bounded by the dimension of $X$).
    We know that the intermediate state contains at least one atom from $T$, so we are only interested in the orbits among $X_1,\ldots,X_n$ which use at least one atom from $T$ on a coordinate that was free in $X$. These orbits have lower dimension,
    so the parties can sequentially apply the induction assumption to check if the intermediate state belongs to any of these orbits.
    This completes the proof of the lemma, and therefore also of \cref{thm:unambiguous-to-protocol}.
\end{proof}
\end{proof}


\subsection{Weighted automata}
\label{sec:weighted-automata-atoms}

In \cref{thm:unambiguous-to-protocol}, we have proved one implication in Conjecture~\ref{conj:protocols-unambiguous}. This section is devoted to presenting some evidence for the other implication, i.e.
\begin{align}\label{eq:missing-orbit-finite-implication}
\text{protocol} \quad \implies \quad \text{unambiguous automaton}.
\end{align}
 We begin by explaining why the techniques that we used to prove this implication in the finite case do not extend to the orbit-finite case. 

\paragraph*{What goes wrong in the orbit-finite case?}
In the finite case, the proof had two parts: (a) a reduction to one-round protocols, and (b) the Myhill-Nerode Theorem. Part (b) does not seem to be problematic, as orbit-finite versions of the Myhill-Nerode Theorem are known in many variants, including monoids~\cite[Lemma 3.3]{bojanczykNominalMonoids2013}, automata~\cite[Section 3.2]{bojanczykAutomataTheoryNominal2014}, and -- as we will prove later in this section -- also for weighted automata. The problematic part is (a), in which the number of rounds is reduced to one. The key argument in this reduction  was that the sets of strategies 
  \begin{align*}
    (Q_B)^k \to (Q_A)^k \qquad \text{and} \qquad (Q_A)^k \to (Q_B)^k
    \end{align*}
are finite, and thus each party could simply send their strategy as a message.  This argument fails to carry over from finite sets to orbit-finite sets. The reason is  that orbit-finite sets are not closed under taking function spaces $X \to Y$, see~\cite{functionSpaces2024} for an extended discussion of this phenomenon.  The following example shows that the one-round reduction is indeed impossible in the orbit-finite case.

\begin{myexample}
    [No reduction to one round]\label{ex:no-one-round-reduction} Consider a language $L$ that is computed by an orbit-finite protocol with one round. Using the same argument as in \cref{lem:one-round-reduction-boolean}, we can show that the Myhill-Nerode equivalence relation for the language, as defined in~\eqref{eq:myhill-nerode-equivalence}, has an orbit-finite set of equivalence classes. As mentioned above, it follows from \cite[Section 3.2]{bojanczykAutomataTheoryNominal2014} that $L$ is also recognised by a deterministic orbit-finite automaton. As we have seen in Example~\ref{ex:protocol-not-dofa}, such automata are not strong enough to capture all protocols.
    %In fact, the reasoning in this example shows that a language is recognised by a one-round orbit-finite protocol if and only if it is recognised by a deterministic orbit-finite automaton in both directions, i.e.~both the language and its reverse are recognised by deterministic orbit-finite automata. 
\end{myexample}

In light of the above example, it is no longer surprising that the proof of \cref{thm:unambiguous-to-protocol} used multi-round protocols. In fact, we believe that the number of needed rounds can be arbitrarily large, as suggested by the following example. 

\begin{myexample}[Back and forth]
    A string over the alphabet $\atoms^2$ can be seen as a directed graph, where each letter represents an edge. For $k \in \set{1,2,\ldots}$, define  $L_k$ to be the set of strings over this alphabet such that: (1) the string is functional, i.e.~for each atom $a$ there is at most letter in the string that begins with $a$; and (2) in the corresponding graph, there is a path with $k$ edges that uses the edges from the first and last letter. This language can be computed by an orbit-finite protocol with $k-1$ rounds, with each round corresponding to a step in the path. It seems unlikely that a smaller number of rounds would suffice, but we do not prove this claim here. 
\end{myexample}



\paragraph*{Weighted orbit-finite automata.} In the reminder of this section, we present some evidence for the missing implication
in Conjecture~\ref{conj:protocols-unambiguous}, using the orbit-finite version of weighted automata. Namely, we will prove
\cref{thm:orbit-finite-protocol-to-weighted}, which states that every language computed by an orbit-finite protocol is also recognised by a weighted orbit-finite automaton over the two-element field.

 In \cref{thm:orbit-finite-protocol-to-weighted}, we will show  that  if a language is computed by a protocol, then it is recognised by a weighted orbit-finite automaton over the two-element field. For finite alphabets, this would be enough to ensure regularity, see \cref{claim:regular-weighted-automata}. This is no longer true in the orbit-finite case, and therefore \cref{thm:orbit-finite-protocol-to-weighted} can only be considered as evidence for the conjecture. However, at the very least it shows that languages computed by orbit-finite protocols are decidable, which was not a priori clear from the definition.

Let us begin by defining the orbit-finite version of weighted automata. 
\begin{definition}[Weighted orbit-finite automata]
    \label{def:weighted-orbit-finite-automata}
    A weighted orbit-finite automaton over a semiring $\domain$ is defined in the same way as in Definition~\ref{def:weighted-automaton-nondeterministic}, except that:
    \begin{enumerate}
        \item the input alphabet and state space are orbit-finite, instead of finite;
        \item the weight functions are equivariant.
    \end{enumerate}
     We require that for every input string, there are finitely many runs with non-zero weight.
\end{definition}

For the purpose of this section, already the special case of the two-element field $\set{0,1}$ is interesting. In this case, the automaton defines a function $\Sigma^* \to \set{0,1}$, which can be seen as the characteristic function of a language. Therefore, we can compare weighted orbit-finite automata to other models, such as nondeterministic orbit-finite automata. The following example shows that these two  models are incomparable. 

\begin{myexample}
    The language ``some letter appears twice'' is recognised by a nondeterministic orbit-finite automaton, but its characteristic function cannot be  recognised by a weighted orbit-finite automaton over the two-element field. The non-expressivity can be proved using the orbit-finite version of the Fliess Theorem, see \cref{thm:orbit-finite-fliess}. On the other hand, the  language ``an even number of distinct letters'' is not recognised by a nondeterministic orbit-finite automaton, while its characterisatic function can  be computed by a weighted orbit-finite automaton, see~\cite[Example 3.2]{orbitFiniteVectorTheoretics}. On the other hand, for every language recognised by an unambiguous orbit-finite automaton, its characteristic function is computed by a weighted orbit-finite automaton, since for unambiguous automata, counting the runs modulo two gives the same result as checking if a run exists. This discussion is summed up in the following picture:
    \mypic{2}
\end{myexample}

The following theorem is the main result of Section~\ref{sec:weighted-automata-atoms}.
\begin{theorem}\label{thm:orbit-finite-protocol-to-weighted}
    Let $\Sigma$ be an orbit-finite input alphabet, and let $\domain$ be a field.
    If a language $L \subseteq \Sigma^*$ is computed by a protocol, then the corresponding characteristic function of type $\Sigma^* \to \set{0,1} \subseteq \domain$  is computed by a weighted orbit-finite automaton.
\end{theorem}


In the proof of the theorem, we use the recently developed theory of orbit-finite vector spaces. In order to streamline the development, we will work with a special case of these spaces, namely spaces which have an orbit-finite basis.
% \begin{definition}
%     [Orbit-finite dimension] A \emph{vector space of orbit-finite dimension} is any vector space of the form $\lincomb X$, where $X$ is some orbit-finite set. 
% \end{definition}
For an orbit-finite set $Q$, let us write $\lincomb Q$ for the vector space which consists of finite formal linear combinations of elements of $Q$. In other words, an element of this space is a vector of the form 
\begin{align*}
\alpha_1 q_1 + \cdots + \alpha_n q_n,
\end{align*}
where the coefficients $\alpha_i$ are from the field, and the element $q_i$ (which can be seen as basis vectors) are from $Q$. Any space of the form $\lincomb Q$ is called a \emph{vector space of orbit-finite dimension}. Such a space has two kinds of structure: one can take linear combinations, and one can apply atom permutations. We will typically be interested in functions between such spaces that preserve both kinds of structure.

In the proof of \cref{thm:orbit-finite-protocol-to-weighted}, we will use an orbit-finite version of the protocols that were developped in Section~\ref{sec:field-domain}. We could use a general version of the protocol, corresponding to an orbit-finite generalisation of Definition~\ref{def:two-party-protocol-general} with field outputs, and prove that it is equivalent to weighted orbit-finite automata. This is indeed true.  However, in order to streamline the exposition, we treat these protocols as a tool to prove \cref{thm:orbit-finite-protocol-to-weighted}, and not an object of independent interest. Therefore, we only define the simplest kind of protocol that is needed for our purposes, namely an orbit-finite variant of the scalar product protocol from Definition~\ref{def:scalar-product-protocol}. It will be more convenient to use a generalisation of scalar products, namely bilinear maps. Recall that a bilinear map inputs two vectors, and is linear in both arguments. 

% This space is equipped with a scalar product, 
% \begin{align*}
% \langle v, w \rangle = \sum_{q \in Q} (\text{coefficient of $q$ in $v$}) \cdot ( \text{coefficient of $q$ in $w$}).
% \end{align*}
% The sum in the above definition is in fact finite, since only finitely many basis vectors will have nonzero coefficients. Using this scalar product, we can define an orbit-finite version of the scalar product protocols from Definition~\ref{def:scalar-product-protocol}.



\begin{definition}
    [Orbit-finite bilinear protocol] 
    \label{def:orbit-finite-scalar-product-protocol}
    An orbit-finite bilinear protocol is given by:
    \begin{enumerate}
        \item two vector spaces $V_A$ and $V_B$ of orbit-finite dimension  and two strategies, which are  equivariant functions
        \begin{align*}
        \sigma_A : \Sigma^* \to V_A 
        \quad \text{and} \quad
        \sigma_B : \Sigma^* \to V_B
        \end{align*}
        \item an output map, which is an equivariant bilinear map 
        \begin{align*}
        \text{out} : V_A \times V_B \to \domain.
        \end{align*}
    \end{enumerate}
\end{definition}
The output of the protocol is defined in the expected way. Alice and Bob apply their strategies to their local strings, yielding two vectors, and the output of the protocol is obtained using the output map. As usual, we require split invariance, i.e.~the output of the protocol should depend only on the input string $w$ and not on its factorisation $w = w_1 w_2$ into local strings. 

Before continuing, let us comment on the difference between scalar products and bilinear maps. Scalar protducts can be extended to vector spaces of orbit-finite dimension in the obvious way, namely
\begin{align*}
\langle v, w \rangle = \sum_{q} (\text{coefficient of $q$ in $v$}) \cdot ( \text{coefficient of $q$ in $w$}),
\end{align*}
where the sum ranges over basis vectors. This sum is in fact finite, since each of the vectors $v$ and $w$ involves only finitely many basis vectors with non-zero coefficients.
Scalar products are a special case of bilinear maps, and therefore every scalar product protocol is a special case of a bilinear protocol. In the context of finite dimension (and not orbit-finite) dimension, using bilinear maps instead of scalar products does not increase the expressive power of the protocols, since bilinear maps are still a special case of the general version from Definition~\ref{def:two-party-protocol-general}. Also in the orbit-finite setting, bilinear maps can be replaced by scalar products, but we do not know a direct proof of this result, other than showing that both models are equivalent to weighted orbit-finite automata, as we will show later in this section. 

Having defined the bilinear protocols, we resume the proof of \cref{thm:orbit-finite-protocol-to-weighted}. The proof has two steps, as described in the following diagram.
\[
\begin{tikzcd}
\text{orbit-finite protocol}
\ar[d,Rightarrow,"\text{Lemma~\ref{lem:orbit-finite-protocol-to-scalar}}"]
\\
\text{orbit-finite bilinear protocol}
%\omc{Here one lemma is missing}
\ar[d,Rightarrow, "\text{Lemma~\ref{lem:scalar-to-weighted}}"]
\\
\text{orbit-finite weighted automaton}
\end{tikzcd}
\]
\omc{Here one lemma is missing}

We begin with the first step, which can be seen as form of reduction to one round, since the bilinear protocols have only one round. Recall that without vector spaces, a reduction to one round was not possible, see Example~\ref{ex:no-one-round-reduction}. This phenomenon is connected to closure under taking function spaces: orbit-finite sets are not closed under taking function spaces, but this closure is recovered once one moves to vector spaces, see~\cite[Section 8.3]{bojanczyk_slightly}. 

\begin{lemma}\label{lem:orbit-finite-protocol-to-scalar}
    If $L \subseteq \Sigma^*$ is computed by an orbit-finite protocol, then the characteristic function is computed by an orbit-finite scalar product protocol, over any field.
\end{lemma}


\begin{proof}
    We first introduce a common generalisation of the two models in the lemma. This genneralisation is called \emph{hybrid protocols}, and it has both multiple rounds (as in the protocols from the assumption of the lemma) and linear combinations (as in the protocols from the  conclusion of the lemma). We then show that the multiple rounds can be eliminated, yielding a protocol as in the conclusion of the lemma. 

    We begin by describing the hybrid protocols. The protocol has $k$ rounds.  In the first $k-1$ rounds, the two parties exchange messages as in the orbit-finite protocol. Then, in the last round, they create two vectors, which are combined using a bilinear map to get the final number. 
    Here is a formal definition of the hybrid protocol. For each round $i \in \set{1,\ldots,k-1}$, the parties exchange messages just as in an orbit-finite protocol, using message spaces $Q_A$ and $Q_B$ and strategies 
        \begin{align*}
        \sigma_{A,i} & : \Sigma^* \times (Q_B)^{i-1} \to Q_A\\
        \sigma_{B,i} & : \Sigma^* \times (Q_A)^{i-1} \to Q_B
        \end{align*}
    Then, in  the last $k$-th round, the message histories are used to produce vectors in two vector spaces $V_A$ and $V_B$ of orbit-finite dimension, using strategies 
    \begin{align*}
        \sigma_{A,k} & : \Sigma^* \times (Q_B)^{k-1} \to V_A\\
        \sigma_{B,k} & : \Sigma^* \times (Q_A)^{k-1} \to V_B.
        \end{align*}
    Finally, from the two vectors, the output is computed using a bilinear map
    \begin{align*}
        \text{out} : V_A \times V_B \to \domain.
    \end{align*}
    

    The hybrid protocol is meant to generalise both orbit-finite protocols and orbit-finite bilinear protocols. For the latter, this is clear: we simply use $k=1$ and there is no message exchange. For the former, we proceed as follows. We use  trivial vector spaces, i.e.~both vector spaces are the field. The bilinear map is multiplication. Once the two parties have agreed on a Boolean decision, they can both send $1$ (in the case of a ``yes'' decision) or $0$ (in the case of a ``no'' decision), and the bilinear map will give the correct output. 
    
    In order to complete the proof of the lemma, we will show that the number of rounds can always be reduced to one, thus yielding a bilinear protocol. 

    \begin{claim}\label{claim:reduce-round}
        For every $k > 1$, a hybrid protocol with $k$ rounds can be simulated by a hybrid protocol with $k-1$ rounds.
    \end{claim}
    \begin{proof}
        We will eliminate round $k-1$, where the last message is sent. Once Alice has received the first $k-2$ messages from Bob, her contribution to the rest of the protocol is described by an object of type 
          \begin{align}\label{eq:contribution-last-two-rounds}
            \myunderbrace{Q_A}{message \\ sent in \\ round $k-1$} \quad \times \quad  \myunderbrace{(\fsfun  {Q_B} {V_A})}{message sent in \\ round $k$, as a function \\ of the message sent \\ in  round $k-1$}
        \end{align}
        We want to turn the above type into a vector space. The second coordinate is already a vector space, since functions with outputs in a vector space can be added and scaled pointwise. What is more, the  second coordinate  is  a vector space of orbit-finite dimension, which is a nontrivial result~\cite[Section 8.3]{bojanczyk_slightly}, i.e.~it has an orbit-finite basis  
        \begin{align*}
        F_A \subseteq \fsfun  {Q_B} {V_A}.  
        \end{align*}
        The first coordinate $Q_A$ can be turned into a vector space by  allowing linear combinations, i.e.~$\lincomb Q_A$. We combine these two using tensor product, yielding a vector space of orbit-finite dimension
        \begin{align*}
           W_A =  (\lincomb Q_A) \otimes (\lincomb F_A).
        \end{align*}
        We can do the same thing for Bob, thus giving a vector space 
        \begin{align*}
           W_B =  (\lincomb Q_B) \otimes (\lincomb F_B),
        \end{align*}
        where $F_B$ is an orbit-finite basis of the vector space $\fsfun  {Q_A} {V_B}$. Define a linear map
        \begin{align*}
        \varphi : W_A \otimes W_B \to \domain
        \end{align*}
        as follows. A basis of the input space for $\varphi$ is 
        \begin{align*}
        Q_A \times F_B \times Q_B \times F_A,
        \end{align*}
        and therefore it is enough to define the map $\varphi$ on the basis. (We want $\varphi$ to be equivariant, and therefore the definition on the basis will need to be equivariant as well.) This definition is the only one that types, namely 
        \begin{align*}
        (q_A, f_B, q_B, f_A) \quad 
        \mapsto \quad 
        \text{out}(f_A(q_B), f_B(q_A)).
        \end{align*}
        The map $\varphi$ is a linear map with domain $W_A \otimes W_B$, and therefore it is a bilinear map with domain $W_A \times W_B$. Because the output map is bilinear, one can check that $\varphi$ defined this way is consistent with the original protocol, i.e.~if we take functions 
        \begin{align*}
        f_A : Q_B \to V_A \qquad \text{and} \qquad f_B : Q_A \to V_B,
        \end{align*}
        which are not necessariy basis vectors from $F_A$ and $F_B$, then we have 
        \begin{align*}
        \text{out}(f_A(q_B), f_B(q_A)) = \varphi((q_A, f_B), (q_B, f_A)).
        \end{align*}
        Therefore, we can implement the last two round of the original hybrid protocol using a single round. The message spaces and the strategies for the first $k-2$ rounds are unchanged. In the last round $k-1$, the new strategies
        \begin{align*}
        \sigma'_{A,k-1} & : \Sigma^* \times (Q_B)^{k-2} \to W_A\\
        \sigma'_{B,k-1} & : \Sigma^* \times (Q_A)^{k-2} \to W_B
        \end{align*}
        output the tensor pairs consisting of the contribution that was described in~\eqref{eq:contribution-last-two-rounds}. Finally, the output  map for the new protocol is $\varphi$. 
    \end{proof}

    By repeatedly applying the above claim, we can reduce the number of rounds to one, in which case we get a bilinear protocol, as required in the statement of the lemma. 
\end{proof}

The second step in the proof of \cref{thm:orbit-finite-protocol-to-weighted} is to show that orbit-finite bilinear protocols are equivalent to weighted orbit-finite automata.  This will be proved similarly to the finite case, see \cref{sec:from-scalar-product-protocol-to-weighted-automaton}, by appealing to the Fliess Theorem. However, we first  need to prove the appropriate  orbit-finite generalisation  of this theorem.

\subsubsection{Fliess Theorem}
In this section, we prove an orbit-finite version of the Fliess Theorem, which characterises functions $\Sigma^* \to \domain$ that are computed by weighted orbit-finite automata. As in the original Fliess Theorem, we will be interested in derivatives of the function, which live in the space  
\begin{align*}
\Sigma^* \to \domain.
\end{align*}
This set has three kinds of structure, all of which will are used in the Fliess Theorem. The first kind of structure is that of a vector space, since we can take linear combinations of functions. The second kind of structure is that of left derivatives, i.e.~for each function $f$ and input string $w \in \Sigma^*$, we can consider the left derivative $v \mapsto f(wv)$. The third kind of structure is that of atom permutations: for each function $f$ and atom permutation $\pi$, we can consider the function $\pi(f)$, which is the composition $\pi;f$.

We say that a subset  $U \subseteq \Sigma^* \to \domain$  is \emph{orbit-finitely spanned} if there is some orbit-finite set $Q$, such that  every element of $U$ is a finite linear combination of elements from $Q$. We do not require the linear combination to be unique, i.e.~we do not require $Q$ to be a basis. (Choosing a basis can be problematic in the context of orbit-finite sets, see~\cite[Example 77]{bojanczyk_slightly}.) We are now ready to state the orbit-finite version of the Fliess Theorem.

\begin{theorem}[Orbit-finite Fliess Theorem]\label{thm:orbit-finite-fliess}
    The following conditions are equivalent for every  function
    \begin{align*}
    f : \Sigma^* \to \domain,
    \end{align*}
    where $\Sigma^*$ is an orbit-finite alphabet, and $\domain$ is a field: 
    \begin{enumerate}
        \item \label{it:fliess-weighted} $f$ is computed by a weighted orbit-finite automaton;
        \item \label{it:fliess-derivatives} $f$ is equivariant and its set of derivatives is orbit-finitely spanned.
        %  there is a finite set $\Gamma$ of derivatives of $f$, such that every derivative of $f$ can be expressed as linear combination
        % \begin{align*}
        % \alpha_1 \pi_1(f_1) + \cdots + \alpha_k \pi_k(f_k),
        % \end{align*}
        % where each $\alpha_i$ is in the field, each $\pi_i$ is an atom permutation, and each $f_i$ is in $\Gamma$.
    \end{enumerate}
\end{theorem}

Before proving this theorem, we use it to complete the proof of \cref{thm:orbit-finite-protocol-to-weighted}. In light of  \cref{lem:orbit-finite-protocol-to-scalar}, it is enough to show that if (the characteristic function of) a  language is computed by an orbit-finite bilinear protocol, then it has  an orbit-finite space of left derivatives. This is explained in the same way as in Section~\ref{sec:beyond-fields}: the vector produced by Alice in a bilinear protocol uniquely determines the left derivative of her part of the input. 

\begin{proof}[Proof of orbit-finite Fliess Theorem] In this proof, the orbit-finite generalisation is proved in the same way as the original theorem, without any significant changes.

    We begin with the implication \ref{it:fliess-weighted} $\implies$ \ref{it:fliess-derivatives}. Consider a weighted orbit-finite automaton with state space $Q$. 
    Define the \emph{pre-weight} of a run in the same way as its weight, except that we do not use the final weight. In other words, this is the product of: (1) the initial weight of the first state; and (2) the weights of all transitions. Consider an input string $w$. Define the \emph{configuration} of $w$ to be the linear combination
    \begin{align}
        \label{eq:configuration-wa}
        \sum_\rho \alpha_\rho \cdot q_\rho,
    \end{align}
    where $\rho$ ranges over runs that have input $w$ and non-zero pre-weight, $\alpha_\rho$ is the pre-weight of the run $\rho$, and $q_\rho$ is the last state in this run (this state is a string, since states are strings). By the assumption that each input string has finitely many runs with non-zero weight, the configuration is a finite sum, i.e.~it belongs to the vector space $\lincomb Q$. The left derivative which corresponds to the input string is uniquely determined by this configuration, and the space of configurations is orbit-finitely spanned. Hence, we get~\ref{it:fliess-derivatives}.

    We now prove the other implication, \ref{it:fliess-derivatives} $\implies$ \ref{it:fliess-weighted}. Assume~\ref{it:fliess-weighted}, which means that   there is an orbit-finite set $Q \subseteq \Sigma^*$ such that every derivative of $f$ can be decomposed as a finite linear combination of left derivatives
    \begin{align*}
            \sum_i \alpha_i \leftderivative{f}{w_i},
        \end{align*}
        where each string $w_i$ is in $Q$. The following claim discusses this decomposition for strings that are obtained by taking a string in $Q$ and appending one letter. 
        \begin{claim}
            There is an equivariant function 
        \begin{align*}
       \delta :  Q \times \Sigma \to \lincomb Q
        \end{align*}
        such that the following conditions holds for every $w \in Q$ and $a \in \Sigma$:
        \begin{align*}
        \delta(w,a) = 
        \sum_i \alpha_i w_i 
        \qquad \Rightarrow \qquad 
        \leftderivative f {wa} = \sum_i \alpha_i \leftderivative{f}{w_i}.
        \end{align*}
        \end{claim}
    \begin{proof}
        Condition~\ref{it:fliess-derivatives} in the theorem says that there is such a function, not necessarily equivariant. The content of the claim is to show that this function can be assumed to be equivariant. Indeed, we can start with any function $\delta$, which is not necessarily equivariant, and then improve it as follows:  for every orbit in $Q \times \Sigma$,  pick a representative $(w,a)$, apply the original function to it, and then extend the result to the whole orbit by equivariance. This improvement  procedure is legitimate thanks to the following equivalence: 
        \begin{align*}
                    \leftderivative{f}{wa} = \sum_i \alpha_i \leftderivative{f}{w_i}
                    \quad \iff \quad 
                            \leftderivative{f}{\pi(wa)} = \sum_i \alpha_i \leftderivative{f}{\pi(w_i)},
        \end{align*}
        The equivalence holds  because equivariance of $f$ ensures that  derivatives commute with atom permutations.
    \end{proof}        

    Using the function $\delta$ from the above claim, we define a weighted orbit-finite automaton. The state space is the set $Q$. (We assume without loss of generality that $Q$ contains the empty string $\varepsilon$. This is not really necessary for the construction, but it makes it more intuitive.) The weights are defined as follows: 
    \begin{itemize}
        \item \textbf{Initial weights.} The initial weight of   $\varepsilon$ is $1$. All other states have initial weight $0$.
        \item \textbf{Transition weights.} The weight of a transition 
        \begin{align*}
        w \xrightarrow{a} v
        \end{align*}
    is the coefficient next $v$ in the linear decomposition $\delta(w,a)$.
        \item \textbf{Final weights.} The final weight of a state $w \in Q$ is $f(w)$.
    \end{itemize}
    In order for this to be a well-defined automaton, there need to be  finitely many runs with non-zero weight for every input string. This is because all linear combinations are finite, which ensures that for each state $w$ there are finitely many outgoing transitions over any input letter $a$ that have nonzero weight.

    Finally, we justify why this automaton computes the function $f$.   A simple inductive proof shows that  
    \begin{align*}
\text{configuration of $w$} = \sum_\rho \alpha_\rho \cdot w_\rho
\quad \implies \quad 
        \leftderivative f w = 
    \sum_\rho \alpha_\rho \cdot \leftderivative f {w_\rho}.
    \end{align*}
    By choice of final weights,  the output of the automaton is equal to $f(w)$. 
\end{proof}

