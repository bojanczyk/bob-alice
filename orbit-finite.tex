% LTeX: language=en
\section{Infinite alphabets}
\label{sec:infinite-alphabets}
\AP
In this section, we present a variant of our model which deals with an input
alphabet. This direction is rooted in the tradition of language theory for
infinite alphabets, which dates back to the work of Kaminski and
Francez~\cite{kaminskiFiniteMemoryAutomata1994}, and has been developed in many
subsequent papers, see e.g.~the
survey~\cite{bojanczykOrbitFiniteSetsTheir2017}. The general idea is that we
have an infinite alphabet $\atoms$ (whose elements are called \intro{atoms}), and the
languages  refer only to equality between letters, as in the following examples
\begin{align}
\setbuild{ w \in \atoms^*}{the first letter is equal to the last letter}
\label{eq:first-last}
\\
\setbuild{ w \in \atoms^*}{some letter appears at least twice}
\label{eq:some-twice}
\end{align}

There are numerous models of automata for such languages, which typically
involve some kind of finite memory, as well as registers that store letters
from $\atoms$. For example, the language~\eqref{eq:first-last} is recognised by
an automaton which loads the first letter into a register, and then toggles
acceptance depending on comparison of the register with the current input
letter. The language~\eqref{eq:some-twice} is recognised by an automaton which
nondeterministically guesses a position, puts its letter into a register, and
then waits for this letter to appear again. 

Numerous models for infinite alphabets have been proposed in the literature,
see Figure~\ref{fig:automata-infinite-alphabets} which contains a sample of
seventeen models. Interestingly, all of those models are pairwise
non-equivalent. This sharply contrasts with the finite-alphabet case, where
virtually all models coincide and capture the regular languages. 

In this section, we describe an infinite-alphabet version of our two-party
protocols. The motivation for this study is twofold: (a) a search for a
canonical model of regular languages for infinite alphabets; and (b)
mathematical interest. Regarding the point (a), we hope that the adaptability
of two-party protocols to various settings will help us  find a canonical model
of regular languages for infinite alphabets. This seems to be at least
partially successful, since there is evidence --- which we present in this
section --- that the protocols are equivalent to one of the existing automaton
models\footnote{
  Thus avoiding proliferation of standards, humanistically depicted in a famous XKCD comic.
}, namely unambiguous register automata, see item~\ref{it:orbit-finite-unamb} in
Figure~\ref{fig:automata-infinite-alphabets}. If true, this
equivalence would be unexpected, since there does not seem to be any syntactic
connection between unambiguous register automata and protocols. Regarding point
(b), one of the exciting features of our protocol model for infinite alphabets
is that the interaction between the two parties becomes essential, and the
protocol cannot be reduced to the one-round case as in
\cref{lemma:one-round-reduction-general}.

\begin{figure}
    \begin{enumerate}
    \item deterministic register automata~\cite[Definition 3]{kaminskiFiniteMemoryAutomata1994}
    \item nondeterministic register automata~\cite[Definition 1]{kaminskiFiniteMemoryAutomata1994}
    \item nondeterministic register automata with guessing~\cite[Definition 2.7]{bojanczyk_slightly}
    \item weighted register automata over the two-element field~\cite[Definition 3.1]{orbitFiniteVectorTheoretics}
    \item two-way deterministic register automata~\cite[Definition 5]{kaminskiFiniteMemoryAutomata1994}
    \item two-way nondeterministic register automata~\cite[Definition 2.1]{nevenFiniteStateMachines2004}
    \item alternating register automata~\cite[p.~16:8]{lazicDemri09}
    \item alternating register automata with one register~\cite[p.~16:19]{lazicDemri09}
    \item \label{it:orbit-finite-unamb} unambiguous register automata~\cite[Section 5]{colcombet2015unambiguity}
    \item register automata with pebbles~\cite[Section 2.2]{nevenFiniteStateMachines2004}
    \item \label{it:single-use} single-use register automata~\cite[Definition 2]{bojanczykstefanski2020}
    \item data automata~\cite[Section 4.2]{bojanczykTwovariableLogicData2011}
    \item class automata~\cite[Section III]{bojanczykExtensionDataAutomata2010} 
    \item regular expressions~\cite[Definition 2]{regexpKaminskiTan2004}
    \item three other kinds of regular expressions~\cite[Sections 4, 5, 6]{regexpLibkin2015}
    \item yet another kind of regular expressions~\cite[Section 5]{KleeneNominal2019}
    \item monadic second-order logic with equality~\cite[Section 2.4]{nevenFiniteStateMachines2004}
    % \item session automata
\end{enumerate}
    \caption{A non-exhaustive list of models of automata for infinite alphabets. All models in the list are pairwise non-equivalent. In contrast, for finite alphabets, all models in this list are equivalent, and define exactly the regular languages. }
    \label{fig:automata-infinite-alphabets}
\end{figure}




% . Regarding the point (b), we note that the theory of automata for infinite alphabets is closely related to the theory of orbit-finite sets~\cite{bojanczyk_slightly}, which builds on the ideas of nominal sets~\cite{PittsAM:nomsns}. This theory has many interesting mathematical aspects, and we hope that our model will be useful in this context.



\subsection{Protocols for an infinite alphabet}
\label{sec:protocols-infinite-alphabet}
\AP
We now give a more detailed description of our model. 
As explained in the introduction, we only care about languages that are closed 
under \intro{permutations of the alphabet}, according to the following definition. 

\begin{definition}[Equivariant language] \label{def:equivariant-language}
  \AP
  A language $L \subseteq \atoms^*$ is called \intro[equivariant language]{equivariant} if 
  \begin{align*}
  w \in L \quad \iff \quad \pi(w) \in L
  \end{align*}
  holds for every permutation $\pi$ of the alphabet $\atoms$.
\end{definition}

Examples of \kl{equivariant languages} include the languages
in~\eqref{eq:first-last} and~\eqref{eq:some-twice}. On the other hand, the
language ``the first letter is a vowel'' or ``the letters are strictly
increasing'' are not \kl{equivariant}, since there is no such thing as a vowel,
or an ordering of the letters. The principle of \kl[equivariant
language]{equivariance} will also be applied to protocols, as described below.


\AP To define \intro{(simple) equivariant protocols} for infinite alphabets, we use the
same kind of \kl{protocols} as in Definition \ref{def:two-party-protocol-boolean},
except that apart from bits, the parties can also send letters from the
alphabet $\atoms$. It follows that the allowed set of messages is
$\set{\text{true, false}} + \atoms$, i.e.~the disjoint union of the Booleans
and the input alphabet. Similarly, to
Definition~\ref{def:two-party-protocol-boolean}, the number of rounds is a
fixed number $k$ and in the $i$-th round each party chooses a new message
according a strategy which is a function of the following type: 

\begin{align*}
\myunderbrace{\atoms^*}{local \\ string} \times \myunderbrace{(\set{\text{true, false}} + \atoms)^{i-1}}{messages received \\ in previous rounds} 
\to
\myunderbrace{\set{\text{true, false}} + \atoms}{message sent \\ in this round}
\end{align*}
In the last round, Bob must send a bit, and this bit is the output of the \kl[simple equivariant protocol]{protocol}.
An important restriction in the protocol is that the strategies of both parties must be \emph{equivariant} in the following sense: 
a strategy $\sigma$ is equivariant if for every permutation $\pi$ of $\atoms$ and for every $i$, it satisfies the following condition:
\begin{align*}
\sigma(w, m_1, \ldots, m_{i-1}) = m_i 
\quad \Rightarrow \quad
\sigma(\pi(w), \pi(m_1), \ldots, \pi(m_{i-1})) = \pi(m_i).
\end{align*}
In the above, $\pi$ is applied to messages in the natural way -- 
it modifies the \kl{atoms} and leaves the Booleans unchanged.

\begin{myexample}[Repetitions cannot be detected]
\label{ex:protocol-not-repetitions}
    Having formally defined the protocols for infinite alphabets,
    we can now revisit Example~\ref{ex:reg-ndet-too-strong} from the introduction
    and prove that the language ``some letter appears at least twice'' cannot be computed by a
    \kl[simple equivariant protocol]{protocol}. 
    Suppose, towards a contradiction, that there is a protocol with
    $k$ rounds that computes this language. Consider an input string with
    $2k+2$ pairwise different letters, split so that Alice and Bob get $k+1$
    letters each. In the execution of the protocol there are at most $k$ \kl{atoms}
    which are sent as messages. In particular, there must be some atom $a$ that
    appears in Alice's part of the input string, but is not sent as a message,
    and similarly there must be some atom $b$ that appears in Bob's part of the
    input string, but is not sent as a message. Consider an \kl{atom permutation}
    $\pi$ which swaps $a$ with $b$. If we apply this atom permutation to
    Alice's part of the string (but not Bob's), then the communication history
    will remain unchanged. In particular, the output of the protocol will be
    the same on both inputs. However, after applying this permutation, the
    input string has a repetition, unlike the original one. 
\end{myexample}


\subsubsection{Orbit-finite sets}
\label{sec:orbit-finite-sets}
\AP
In this section, we do a more systematic analysis of automata models for
infinite alphabets, and their relationship to our protocols. As an organising
principle, we use the approach of orbit-finite sets,
see~\cite{bojanczykOrbitFiniteSetsTheir2017} for a longer survey, which is a
generalisation of finite sets suitable for infinite alphabets sets. Using this
notion, we can lift any model of computation that uses finite sets, to a model
that uses orbit-finite sets, which allows us for a clean comparison of the two
setting. For the purposes of this paper, we use a simplified definition of
orbit-finite sets, which is sufficient for our purposes\footnote{
Definition~\ref{def:orbit-finite-sets} is weaker than the usual notion of orbit-finite sets~\cite[Section 5]{bojanczyk_slightly}; in fact it is the special case of the usual notion that is called \emph{polynomial orbit-finite sets} in~\cite[Section 1]{bojanczyk_slightly}.
The stronger  notion that is usually used  allows for two extra features: (a) restricting to equivariant subsets (e.g.~one could limit $\atoms^2$ to pairs which are non-repeating); and (b)  symmetries (e.g.~one could identify pairs in $\atoms^2$ if they agree up to swapping of coordinates, thus yielding unordered pairs). In some cases, the extra features are desirable, in particular they establish a connection with set theory~\cite{blassDedekind2016} and  nominal sets~\cite[Section 5]{PittsAM:nomsns}. However, those features do not play any role in the analysis of protocols and automata and, to avoid technicalities, we use the simpler polynomial version from Definition~\ref{def:orbit-finite-sets}. This simplification is purely technical --- all results continue to hold for the usual notion of orbit-finite sets.
}.
%   instead of the fully general notion of orbit-finite sets, we use a special case, which is called \emph{polynomial orbit-finite sets}. This special case has a more concrete defnition, and is sufficient for our purposes. 
\begin{definition}[Orbit-finite sets] \label{def:orbit-finite-sets}
  \AP
  An \intro{orbit-finite set} is any set of the form 
    \begin{align*}
    \atoms^{d_1} + \cdots + \atoms^{d_n},
    \end{align*}
    for some natural numbers $d_1,\ldots,d_n \in \set{0,1,\ldots}$. 
\end{definition}

\AP
When a summand $\atoms^{d_i}$ uses $d_i =0$, then it  describes a set with
exactly one element, namely the empty tuple. Therefore, \kl{orbit-finite sets}
generalise finite sets, since a  finite set with $n$ elements can be seen as
the orbit-finite set which has $n$ disjoint copies of $\atoms^0$. We will only
be interested in subsets of orbit-finite sets and functions between them that
are \intro{equivariant}, i.e.~invariant under permutations of the \kl{atoms}, in
the following sense:
\begin{align*}
\myunderbrace{x \in X \iff \pi(x) \in X}{equivariant subset $X$ \\ of an orbit-finite set}
\qquad 
\myunderbrace{f(x) = y \iff f(\pi(x)) = \pi(y)}{equivariant function $f$ \\ between two orbit-finite sets}
\end{align*}
We can now discuss various orbit-finite models of computation, by generalising
finite sets to orbit-finite ones, and requiring all subsets and relations to be
\kl{equivariant}. As a first example of this approach, we can revisit the definition
of \kl{simple equivariant protocols} from Section~\ref{sec:protocols-infinite-alphabet}, and
define it in terms of \kl{orbit-finite sets}:

\begin{definition}[Orbit-finite protocol]
    \label{def:orbit-finite-protocol}
    An \intro{orbit-finite Boolean two-party protocol}
    is defined in the same way as in Definition \ref{def:two-party-protocol-boolean}, except that:
  \begin{enumerate}
    \item the input alphabet $\Sigma$, and the message spaces $Q_A$ and $Q_B$ are \kl{orbit-finite}; and 
    \item the \kl{strategies} of both players and the output function are \kl{equivariant}.
  \end{enumerate}
\end{definition}

Indeed, the \kl{simple equivariant protocols} from
Section~\ref{sec:protocols-infinite-alphabet} are the special case of the above
definition where the input alphabet is $\atoms$, and the message spaces are
both equal to 
\begin{align*}
\myunderbrace{\atoms}{letter} + \myunderbrace{\atoms^0}{bit 0} + \myunderbrace{\atoms^0}{bit 1}.
\end{align*}
On the other hand, the \kl[simple equivariant protocol]{special case} is also
equivalent to the \kl[orbit-finite protocols]{general case}, since an element of a general \kl{orbit-finite set}
can be transmitted using a constant number of bits and \kl{atoms} (by first sending
the index of the summand, and then sending the tuple of atoms). It follows that
the protocols from Definition~\ref{def:orbit-finite-protocol} and those from
Section~\ref{sec:protocols-infinite-alphabet} have the same expressive power.
From now on we will use the formalisation from
Definition~\ref{def:orbit-finite-protocol}.

Orbit-finiteness can also be used to define automata. The following definition
has the same expressive power as the standard (nondeterministic and
deterministic) register automata for infinite alphabets
from~\cite{kaminskiFiniteMemoryAutomata1994}; this equivalence was shown
in~\cite[Lemma 6.3]{bojanczykAutomataTheoryNominal2014} and is one of the
original motivations for studying orbit-finiteness.

\begin{definition}
    [Orbit-finite automata]
    \label{def:orbit-finite-automata}
    \AP
    A \intro{nondeterministic orbit-finite automaton} is defined in the same way as a 
    nondeterministic finite automaton, except that all sets are orbit-finite, 
    and all subsets and functions are \kl{equivariant}:
\begin{align*}
    \myoverbrace{
        \myunderbrace{Q}{states} \quad 
        \myunderbrace{\Sigma}{input \\ alphabet}
    }
    {orbit-finite}
    \qquad
    \myoverbrace{
        \myunderbrace{I \subseteq Q}{initial \\ states} \quad 
        \myunderbrace{F \subseteq Q}{final \\ states} \quad 
        \myunderbrace{\Delta \subseteq Q \times \Sigma \times Q}{transitions}
    }{equivariant}.
\end{align*}
A \intro{deterministic orbit-finite automaton}
is the special case which has exactly one initial state, and where the transition relation is a function.
\end{definition}

As stated in Figure~\ref{fig:automata-infinite-alphabets}, deterministic and
nondeterministic orbit-finite automata have different expressive power.
Moreover, as stated in Examples~\ref{ex:reg-det-too-weak}~and~\ref{ex:reg-ndet-too-strong}
none of these models is equivalent to \kl{orbit-finite protocols}:
\kl[of dfa]{deterministic automata} are too weak, and 
\kl[of nfa]{nondeterministic automata} are too
strong. Example~\ref{ex:reg-ndet-too-strong} was already revisited in Example~\ref{ex:protocol-not-repetitions}, and we now revisit Example~\ref{ex:reg-det-too-weak}:  

\begin{myexample} [Deterministic too weak]\label{ex:protocol-not-dofa}
  Every \kl{deterministic orbit-finite automaton} can be simulated by a 
  \kl[of protocol]{protocol}, in the same way as for finite alphabets.
  Alice simulates the run of the automaton on her part of the input, 
  and sends the intermediate orbit-finite state (as an orbit-finite message)
  to Bob who continues the simulation.  
  
  The inclusion is strict: The language ``the last letter appears at least
  twice'' can be computed by a \kl[of protocol]{protocol} (as explained in
  Example~\ref{ex:reg-det-too-weak}), but cannot be recognised by a 
  \kl{deterministic orbit-finite automaton}. Indeed, in order to compare the
  last letter with all previous letters, the automaton would need to store all
  those letters in its orbit-finite state, which is impossible since the number of letters 
  is unbounded. (See \cite[Example~4]{kaminskiFiniteMemoryAutomata1994} for a formal proof).
\end{myexample}

In Definition~\ref{def:orbit-finite-automata}, we have defined \kl{one-way
orbit-finite automata}, which read the input string from left to right. A
natural extension are the two-way automata, which can move their reading head
in both directions according to their transition function. This extension is
particularly natural in the context of protocols, with their two-way
interaction between the communicating parties. However, in the orbit-finite
setting, two-way automata are very strong:

\begin{myexample}[Two-way too strong]\label{ex:protocol-not-2dofa}
    The language ``some letter appears at least twice'' can also be recognised
    by a deterministic two-way orbit-finite automaton~\cite[Example
    18]{bojanczyk_slightly}. Therefore, this automaton model cannot be
    simulated by protocols.

    The reason why two-way orbit-finite automata are so strong is that they can
    make an unbounded number of visits to any given position -- for example the
    automaton for the language ``some letter appears at least twice'' will
    visit the last position a linear number of times (the length of its run is
    quadratic). One idea to tame this power is to consider the bounded-crossing
    variant of two-way automaton, which has a fixed bound $k$ on the number of
    times that the automaton can visit a position \cite[p.~92]{neven2003power}.
    We believe that this model can actually be equivalent to the protocols.
    However, in our conjecture, we will focus on the better studied model
    presented in the following section.
\end{myexample}

\subsection{Unambiguous orbit-finite automata}
\label{sec:unambiguous-orbit-finite-automata}
\AP
As we have shown in Examples~\ref{ex:protocol-not-dofa},
\ref{ex:protocol-not-nofa} and \ref{ex:protocol-not-2dofa},
\kl[of protocol]{protocols} are not equivalent to one-way deterministic or
nondeterministic orbit-finite automata, or their two-way variants automata. So
what is the right automaton model?  We conjecture that the answer is
\intro{unambiguous orbit-finite automata}, i.e.~the special case of
\kl{nondeterministic orbit-finite automata} that have zero or one accepting runs for
every input string.

\begin{conjecture}
    \label{conj:protocols-unambiguous}
    A language over an \kl{orbit-finite} alphabet is computed by 
    an \kl{orbit-finite protocol} if and only if it is recognised by an \kl{unambiguous orbit-finite automaton}.
\end{conjecture}

One corollary of this conjecture would be that \kl{unambiguous orbit-finite
automata} are closed under complement, since \kl[of protocol]{protocols} can
be complemented by flipping the output bit. This corollary has been conjectured
in~\cite[p.9]{colcombet2012forms}, and to the best of our knowledge remains
open, despite apparent claims to the contrary in~\cite[Footnote
5]{colcombet2015unambiguity}.

In this section, we prove implication $\impliedby$ in the conjecture, i.e.~we
show that \kl{orbit-finite protocols} can simulate \kl{unambiguous orbit-finite
automata}. Unlike similar results earlier in this paper, this simulation is
non-trivial. Also, despite the one-way nature of the automata, the simulation
crucially depends on the interactive nature of protocols, i.e.~it requires more
than one round of communication. In particular multi-round protocols cannot be
reduced to one round, as was the case for finite alphabets
(i.e.~\cref{lemma:one-round-reduction-general} is no longer true for the
orbit-finite case).

\begin{theorem}
    \label{thm:unambiguous-to-protocol}
    If a language $L$ over an \kl{orbit-finite} alphabet is recognised by 
    \kl{an unambiguous orbit-finite automaton}, then 
    it is also computed by an \kl{orbit-finite protocol}.
\end{theorem}
\begin{proof}
  For the rest of this proof fix an \kl{unambiguous orbit-finite automaton}, whose state space is the \kl{orbit-finite} set $Q$.
Suppose that the input string is factorized as $w = w_1 w_2$. The general idea of the protocol is that Alice and Bob will jointly
compute the intermediate state (if it exists), i.e.~the state $q$ which satisfies:
\begin{align*}
\myunderbrace{I \xrightarrow{w_1}q}{there is a run over $w_1$\\ from an initial state to $q$} \qquad \text{and} \qquad
\myunderbrace{q \xrightarrow{w_2} F}{there is a run over $w_2$\\ from $q$ to a final state.}
\end{align*}
By \kl{unambiguity}, there is at most one intermediate state, and it exists if and only if the string is accepted.

Observe that Alice can compute the set of states that are reachable from an
initial state by reading her string $w_1$, and Bob can compute the set of
states from which a final state is reachable by reading his string $w_2$. So,
the challenge is to compute their intersection, which is either a singleton
with the intermediate state, or the empty set. Before we explain how to do
this, let us first explain why this is non-trivial, i.e. why Alice cannot send
her set of states to Bob, or vice versa. The problem is that the set of all
reachable subsets of $Q$ is not \kl{orbit-finite}, and therefore it cannot be sent
in a constant number of messages. This issue is illustrated in the following
example.

\begin{myexample}
    \mb{rozwinac to tutaj}
    For example, if we consider the automaton for the language ``the last letter appears at least twice'' that non-deterministically guesses the penultimate appearance of the last letter, 
then the set of all reachable states after reading $w_1$ contains all the atoms that appear in $w_1$, which is unbounded (as it can grow with the length of $w_1$).
 It follows
that the set of all reachable subsets of $Q$ is orbit-infinite\footnote{
This observation can be summarized by saying that orbit-finiteness
is not preserved by the powerset construction. Is one of the main obstacles when working with orbit-finite sets. For example, it is the reason why nondeterministic orbit-finite automata are more powerful than deterministic ones.}
\end{myexample}

To work around the issue explained above, Alice and Bob will engage in interactive communication, which will narrow down the set of possible candidates. At each stage, the set of possible candidates will be represented using orbits, as defined below.

\begin{definition}[Orbit] \label{def:orbit}
  \AP
  For a finite set $S \subseteq \atoms$, the \intro{$S$-orbit} of $q \in Q$ is the following set:
    \begin{align*}
    \setbuild{ \pi(q)}{$\pi$ is a permutation of $\atoms$ such that $\pi(a)=a$ for all $a \in S$}.
    \end{align*}
  The set $S$ is called the \intro{support} of the orbit.
\end{definition}

\begin{myexample}\label{ex:tau-disjoint}
    Let $Q = \atoms^5$, and consider the $\set{\text{{John}, {Eve}}}$-orbit of the following tuple
    \begin{center}
        (\red{John}, Tom, Mary, Tom, \red{Eve})
    \end{center}
    An element of this \kl{orbit} is any tuple of the form 
    \begin{center}
        (\red{John}, $a$, $b$, $a$, \red{Eve})
    \end{center}
    where $a$ and $b$ are distinct \kl{atoms}, which are not \red{John} or \red{Eve}. 
    % Two elements of this orbit are $\tau$-disjoint if the corresponding choices $\set{a_1,b_1}$ and $\set{a_2,b_2}$ are disjoint sets. 
\end{myexample}

\AP As the \kl{support} increases, the \kl{orbit} becomes smaller; in
particular the biggest orbits are the ones with empty support, i.e. the
$\emptyset$-orbits, which we call the \intro{equivariant orbits}. It is not
hard to see that every \kl{orbit-finite} set has a finite number of
\kl{equivariant orbits}~\cite[Lemma 1.4]{bojanczyk_slightly}; in fact this is
the reason for the name. Each \kl{orbit} in an \kl{orbit-finite} set is a
subset of $\atoms^d$ for some $d$. In such an orbit, we partition the
coordinates $\set{1,\ldots,d}$ into two parts: the \intro{fixed coordinates},
which use the \kl{atoms} from the \kl{support}, and the \intro{free
coordinates}, which do not use these atoms. In Example~\ref{ex:tau-disjoint},
the \kl{fixed coordinates} are  the first and last ones, while the \kl{free
coordinates} are the middle three. The \intro[orbit dimension]{dimension} of an
orbit is the number of distinct atoms in the \kl{free coordinates}. In
Example~\ref{ex:tau-disjoint}, the \kl[orbit dimension]{dimension} is two,
corresponding to the atoms $a$ and $b$. An important special case is when the
\kl[orbit dimension]{dimension} is zero; in this case the orbit contains only one state.

In the \kl[of protocol]{protocol}, Alice and Bob will jointly maintain a set
$S \subseteq \atoms$ and list of \kl{$S$-orbits} which may contain the
intermediate state (starting with $S = \emptyset$ the list of all
$\emptyset$-orbits). They will ensure that if the intermediate state exists,
i.e.~if the input string is accepted,  then the intermediate state is contained
in one of the \kl{orbits} on the list. The goal is to decrease the \kl[orbit
dimension]{dimension} of the orbits on the list until they become
\kl{zero-dimensional}, by gradually computing the set $S$ of atoms that appear in
the intermediate state. Once the orbits become zero-dimensional, they will
contain only a finite (and bounded) number of the candidates. At this point,
Alice can compute which of these candidates are reachable from an initial state
over $w_1$ and send this (bounded) information to Bob, who can then check if
one of these candidates can reach a final state over $w_2$. 

To decrease the \kl[orbit dimension]{dimension} and increase $S$, we will use the following lemma.
\begin{lemma}\label{lem:fixed-atoms}
  Let $S \subset \atoms$ be a finite set, and let $\varphi \subseteq Q$ be an infinite \kl{$S$-orbit}
  of \kl[orbit dimension]{dimension} $k$. 
  Consider an input string $w = w_1 w_2$, and the sets:
  \begin{align*}
  \myunderbrace{X_1 = \setbuild{ q \in \varphi}{$ I \xrightarrow{w_1} q$}}{states reachable on Alice's side}
  \qquad
  \myunderbrace{X_2 = \setbuild{ q \in \varphi}{$ q \xrightarrow{w_2} F$}}{states reachable on Bob's side}
  \end{align*}
  There is a set $T \subseteq \atoms$ of size at most $k$, such that either: 
  \begin{enumerate}
    \item   every state from $X_1$ contains an \kl{atom} of $T$ on some \kl{free coordinate}; or 
    \item   every state from $X_2$ contains an \kl{atom} of $T$ on some \kl{free coordinate}.
  \end{enumerate}
\end{lemma}
    \begin{proof}
      \AP
 In the proof of the lemma, we use an analysis of disjointness, which is
 inspired by the sunflower lemma. We say that two states $p,q$ in an \kl{$S$-orbit}
 are \intro{$S$-disjoint} if 
 \begin{align*}
    \forall a \in \atoms 
    \qquad 
 \text{$a$ appears in both $p$ and $q$} \quad \Rightarrow \quad a \in S.
 \end{align*}
 For example, if we take the $\{\textrm{John}, \textrm{Eve}\}$-orbit from Example~\ref{ex:tau-disjoint}, then the two states
\begin{center}
    (\red{John}, Tom, Mary, Tom, \red{Eve}) \qquad
    (\red{John}, Ann, Timmy, Ann, \red{Eve})
\end{center}
are $\{\textrm{John}, \textrm{Eve}\}$-disjoint, because the sets
$\set{\text{Tom, Mary}}$ and $\set{\text{Ann, Timmy}}$ are disjoint. In other
words, the atoms from $S$ can repeat (in fact, they must), but all other atoms
must be disjoint in the two states.

The following claim characterises subsets of orbits that do not contain any pair of disjoint elements:
\begin{claim}\label{claim:sunflower}
  Let $Q$ be an \kl{$S$-orbit} type of \kl[orbit dimension]{dimension} $d$, and let $X$ be a subset of $Q$.
  If $X$ does not contain two \kl{$S$-disjoint} elements, then there is a
  set $T$ of at most $d$ atoms such that every element of $X$ uses at last one atom from $T$ on a \kl{free coordinate}.
\end{claim}
\begin{proof}
        Take some element $x \in X$. Either there is an element of $X$ that is completely disjoint with $x$, or otherwise some atom from $x$ must appear in every other element of $X$ on a free coordinate.
\end{proof}

The claim leaves us with showing that at least one of $X_1$ or $X_2$ does not
contain an \kl{$S$-disjoint} pair of elements. Suppose, towards a contradiction that
both $X_1$ and $X_2$ contain \kl{$S$-disjoint} pairs of elements, say $p_1, p_2 \in
X_1$ and $q_1, q_2 \in X_2$. It follows that the two pairs $(p_1,p_2)$ and
$(q_1,q_2)$ are in the same \kl{equivariant orbit} (of $Q \times Q$), i.e. there is
some atom permutation $\pi$ which sends $p_1$ to $q_1$ and $p_2$ to $q_2$.
Applying $\pi$ to Alices's part of the input string, we obtain a new input
string $\pi(w_1) w_2$, in which both $q_1$ and $q_2$ are valid intermediate
states. It follows that there are at least two accepting runs (one that passes
through $q_1$ and one that passes through $q_2$), contradicting the \kl{unambiguity}
assumption. 
\end{proof}

Using the above lemma, we will construct a \kl[of protocol]{protocol} that
simulates the automaton. As explained before, the idea is to narrow down orbit
which contains the intermediate state. This idea is formalised in the following
lemma. 


\begin{lemma}\label{lem:narrow-down-orbit}
  Let $S$ be a finite subset of \kl{atoms}, and let $X \subseteq Q$ be an \kl{orbit}. 
  Alice and Bob can exchange a constant number of messages
  -- which depends only on the \kl[orbit dimension]{dimension} of $X$ -- 
  to determine if the intermediate state belongs to $X$. 
\end{lemma}

Before proving the lemma, let us explain how to use it to complete the proof of
\cref{thm:unambiguous-to-protocol}. We know that the set of all states $Q$
splits into constant number of \kl{equivariant orbits}, so the two parties can run
the protocol the lemma for each of these orbits with $S=\emptyset$. Each run of
the protocol uses a constant number of rounds, so the total number of rounds is
also constant. It remains to prove the lemma.

\begin{proof}[Proof of \cref{lem:narrow-down-orbit}]
  The proof proceeds by induction on the \kl{dimension of the orbit} $X$.
    
  The induction basis is when the dimension is zero. In this case, the orbit
  has exactly one state, and Alice and Bob can simply check  if the state is
  reachable on their side and exchange this bit of information.

  Consider now the induction step. Apply \cref{lem:fixed-atoms}, to the
  orbit. In the factorisation $w = w_1 w_2$, at least one of the two
  alternatives in the conclusion of \cref{lem:fixed-atoms} must hold. Alice
  can check if the first alternative holds, and Bob can check if the second
  alternative holds.  At least one of the two parties must report success,
  which is witnessed by some finite set $T$ of atoms. The successful party sends the
  set $T$ to the other party. This is possible since the size of $T$ is
  bounded by the \kl[orbit dimension]{dimension} of $X$. 
  The orbit $X$ splits into finitely many
  orbits $X_1,\ldots,X_n$ with the larger \kl[of support]{support} $S \cup T$, see~\cite[Lemma
  10.9]{bojanczyk_slightly}. The number $n$ depends only on the \kl[orbit dimension]{dimension} 
  of $X$ (as the size of $T$ is bounded by the dimension of $X$).

  We know that the intermediate state contains at least one atom from $T$, so
  we are only interested in the orbits among $X_1,\ldots,X_n$ which use at
  least one atom from $T$ on a coordinate that was \kl[free coordinate]{free} in $X$. 
  These orbits
  have lower \kl[of dimension]{dimension}, so the parties can sequentially apply the induction
  assumption to check if the intermediate state belongs to any of these
  orbits. This completes the proof of the lemma, and therefore also of
  \cref{thm:unambiguous-to-protocol}.
\end{proof}
\end{proof}


\subsection{Weighted automata}
\label{sec:weighted-automata-atoms}

\AP
In \cref{thm:unambiguous-to-protocol}, we have proved one implication in Conjecture~\ref{conj:protocols-unambiguous}.
This section is devoted to presenting some evidence for the other implication, i.e.
\begin{align}\label{eq:missing-orbit-finite-implication}
\text{protocol} \quad \implies \quad \text{unambiguous automaton}.
\end{align}
We begin by explaining why the orbit-finite case cannot be handled using the
techniques that were used to prove this implication in the finite case.

\paragraph*{What goes wrong in the orbit-finite case?}
In the finite case, the proof had two parts: (a) a reduction to \kl{one-round protocols}, and (b) the Myhill-Nerode Theorem.
Part (b) does not seem to be problematic, as orbit-finite versions of the Myhill-Nerode Theorem are known in many variants, 
including monoids~\cite[Lemma 3.3]{bojanczykNominalMonoids2013}, automata~\cite[Section 3.2]{bojanczykAutomataTheoryNominal2014}, 
and -- as we will prove later in this section -- also for weighted automata. 
The problematic part is (a), in which the number of rounds is reduced to one.
The key argument in this reduction  was that the sets of strategies 
  \begin{align*}
    (Q_B)^k \to (Q_A)^k \qquad \text{and} \qquad (Q_A)^k \to (Q_B)^k
    \end{align*}
are finite, and thus each party could simply send their strategy as a message.
This argument fails to carry over from finite sets to orbit-finite sets. 
The reason is that \kl{orbit-finite} sets are not closed under taking function spaces $X \to Y$, see~\cite{functionSpaces2024} 
for an extended discussion of this phenomenon.
The following example shows that the one-round reduction 
is indeed impossible in the orbit-finite case.

\begin{myexample}
    [No reduction to one round]\label{ex:no-one-round-reduction}
    Consider a language $L$ that is computed by an \kl{orbit-finite protocol} with
    one round. Using the same argument as in
    \cref{lem:one-round-reduction-boolean}, we can show that the Myhill-Nerode
    equivalence relation for the language, as defined
    in~\eqref{eq:myhill-nerode-equivalence}, has an \kl{orbit-finite} set of
    equivalence classes. As mentioned above, it follows from \cite[Section
    3.2]{bojanczykAutomataTheoryNominal2014} that $L$ is also recognised by a
    \kl{deterministic orbit-finite automaton}. As we have seen in
    Example~\ref{ex:protocol-not-dofa}, such automata are not strong enough to
    capture all \kl[of protocol]{protocols}.
    %In fact, the reasoning in this example shows that a language is recognised by a one-round orbit-finite protocol if and only if it is recognised by a deterministic orbit-finite automaton in both directions, i.e.~both the language and its reverse are recognised by deterministic orbit-finite automata. 
\end{myexample}

In light of the above example, it is no longer surprising that the proof of
\cref{thm:unambiguous-to-protocol} used multi-round protocols. In fact, we
believe that the number of needed rounds can be arbitrarily large, as suggested
by the following example. 

\begin{myexample}[Back and forth]
    A string over the alphabet $\atoms^2$ can be seen as a directed graph, where each letter represents an edge. For $k \in \set{1,2,\ldots}$, define  $L_k$ to be the set of strings over this alphabet such that: (1) the string is functional, i.e.~for each atom $a$ there is at most letter in the string that begins with $a$; and (2) in the corresponding graph, there is a path with $k$ edges that uses the edges from the first and last letter. This language can be computed by an orbit-finite protocol with $k-1$ rounds, with each round corresponding to a step in the path. It seems unlikely that a smaller number of rounds would suffice, but we do not prove this claim here. 
\end{myexample}



\paragraph*{Weighted orbit-finite automata.} In the reminder of this section,
we present some evidence for the missing implication in
Conjecture~\ref{conj:protocols-unambiguous}, using the orbit-finite version of
weighted automata. Namely, we will prove
\cref{thm:orbit-finite-protocol-to-weighted}, which states that every language
computed by an \kl{orbit-finite protocol} is also recognised by a \kl{weighted
orbit-finite automaton} over the two-element field. For finite alphabets, this
would be enough to ensure \kl[regular language]{regularity}, see
\cref{claim:regular-weighted-automata}. This claim is no longer true in the
orbit-finite case, see Example~\ref{ex:weighted-vs-nondet-orbit-finite}, and
therefore \cref{thm:orbit-finite-protocol-to-weighted} can only be considered
as evidence for the conjecture. However, at the very least it shows that
languages computed by orbit-finite protocols are decidable, which was not a
priori clear from the definition.

Let us begin by defining the orbit-finite version of weighted automata. 
\begin{definition}[Weighted orbit-finite automata]
    \label{def:weighted-orbit-finite-automata}
    \AP
    A \intro{weighted orbit-finite automaton} over a semiring $\domain$ is 
    defined in the same way as in Definition~\ref{def:weighted-automaton-nondeterministic}, except that:
    \begin{enumerate}
      \item the input alphabet and state space are \kl{orbit-finite}, instead of finite;
      \item the functions in~\eqref{eq:weight-functions} are \kl{equivariant}.
    \end{enumerate}
     We require that for every input string, there are only finitely many runs with non-zero weight.
\end{definition}

For the purpose of this section, already the special case of the two-element
field $\set{0,1}$ is interesting. In this case, the automaton defines a
function $\Sigma^* \to \set{0,1}$, which can be seen as the characteristic
function of a language. Therefore, we can compare \kl{weighted orbit-finite
automata} to other models, such as \kl{nondeterministic orbit-finite automata}. The
following example shows that these two  models are incomparable. 

\begin{myexample}\label{ex:weighted-vs-nondet-orbit-finite}
  The language ``some letter appears twice'' is recognised by a
  \kl{nondeterministic orbit-finite automaton}, but its characteristic function
  cannot be  recognised by a \kl{weighted orbit-finite automaton} over the
  two-element field. The non-expressivity can be proved using the orbit-finite
  version of the Fliess Theorem, see \cref{thm:orbit-finite-fliess}. On the
  other hand, the  language ``an even number of distinct letters'' is not
  recognised by a nondeterministic orbit-finite automaton, while its
  characteristic function can be computed by a \kl{weighted orbit-finite
  automaton}, see~\cite[Example 3.2]{orbitFiniteVectorTheoretics}. Therefore,
  the two models -- nondeterministic and weighted in the two-element field --
  are incomparable. Inside the intersection of these two classes we will find
  the \kl[of unambiguous automata]{unambiguous automata}, since for unambiguous automata, counting the runs
  modulo two gives the same result as checking if a run exists. This discussion
  is summed up in the following picture:
    \mypic{2}
\end{myexample}

The following theorem is the main result of Section~\ref{sec:weighted-automata-atoms}.
\begin{theorem}\label{thm:orbit-finite-protocol-to-weighted}
  Let $\Sigma$ be an \kl{orbit-finite} input alphabet, and let $\domain$ be a field.
  If a language $L \subseteq \Sigma^*$ is computed by a \kl[of protocol]{protocol}, 
  then the corresponding characteristic function of type $\Sigma^* \to \set{0,1} \subseteq \domain$
  is computed by a \kl{weighted orbit-finite automaton}.
\end{theorem}

In the proof of the theorem, we use the recently developed theory of
orbit-finite vector spaces \cite{orbitFiniteVectorTheoretics}. To streamline
the presentation, we will use a special case of these spaces, namely those that
have an orbit-finite basis. We begin by summarizing the necessary background.

For an orbit-finite set $Q$, let us write $\lincomb Q$ for the vector space
which consists of finite formal linear combinations of elements of $Q$. In
other words, an element of this space is a vector of the form 
\begin{align*}
\alpha_1 q_1 + \cdots + \alpha_n q_n,
\end{align*}
where the coefficients $\alpha_i$ are from the field, and the element $q_i$ (which can be seen as basis vectors) are from $Q$. We use such spaces as the orbit-finite generalisation of finite dimension\footnote{Similarly to the case of orbit-finite sets, we use a simplified definition for this paper, as compared to the literature. The usual notion of vector spaces for orbit-finite sets, see \cite[Definition 8.1]{bojanczyk_slightly} allows for more features; these features are irrelevant for our application and hence not discussed here.}.

\begin{definition}
    [Vector space of orbit-finite dimension]\label{def:orbit-finite-vector-space}
    \AP
    A \intro{vector space of orbit-finite dimension} 
    is a vector space of the form $\lincomb Q$ for some \kl{orbit-finite} set $Q$.
\end{definition}
A space as in the above definition is equipped with two structures: as a vector
space it is closed under linear combinations, and as a set with \kl{atoms} it
is closed under applying \kl{atom permutations}. We will typically be
interested in functions between such spaces that preserve both of those
structures.

In the proof of \cref{thm:orbit-finite-protocol-to-weighted}, we will use an
orbit-finite version of \kl{protocols} with field outputs. Recall that there
are two variants: the general version from Section~\ref{sec:intro-field} and
the simpler \kl{scalar-product protocols} from Section~\ref{sec:field-domain}.
We could begin with the general version and show that it is equivalent to the
scalar-product one -- this is indeed the case. However, to keep the exposition
concise, we treat \kl{orbit-finite protocols} with field outputs merely as a tool
for proving \cref{thm:orbit-finite-protocol-to-weighted}, rather than as an
object of independent interest. Therefore, we focus on the simplest form of
protocol required for the proof, namely an orbit-finite version of the scalar
product protocols from Section~\ref{sec:field-domain}. In the orbit-finite
case, instead of scalar products we will use the slightly more general notion
of bilinear maps, i.e.~maps that have two arguments and are linear in each
argument separately\footnote{It is possible to define orbit-finite scalar
  product protocols, but they are harder to work with. In particular, from our
  results it will follow that orbit-finite scalar product protocols (suitably
  defined) and orbit-finite bilinear protocols are equivalent, but we are not
  aware of a direct proof of this fact.}. 

% This space is equipped with a scalar product, 
% \begin{align*}
% \langle v, w \rangle = \sum_{q \in Q} (\text{coefficient of $q$ in $v$}) \cdot ( \text{coefficient of $q$ in $w$}).
% \end{align*}
% The sum in the above definition is in fact finite, since only finitely many basis vectors will have nonzero coefficients. Using this scalar product, we can define an orbit-finite version of the scalar product protocols from Definition~\ref{def:scalar-product-protocol}.

\begin{definition}
    [Orbit-finite bilinear protocol] 
    \label{def:orbit-finite-scalar-product-protocol}
    \AP
    An \intro{orbit-finite bilinear protocol} consists of:
    \begin{enumerate}
      \item two \kl{vector spaces of orbit-finite dimension}
        $V_A$ and $V_B$ and two strategies, which are equivariant functions
        \begin{align*}
        \sigma_A : \Sigma^* \to V_A 
        \quad \text{and} \quad
        \sigma_B : \Sigma^* \to V_B
        \end{align*}
        \item an output map, which is an equivariant bilinear map 
        \begin{align*}
        \text{out} : V_A \times V_B \to \domain.
        \end{align*}
    \end{enumerate}
\end{definition}
The output of the \kl[of bilinear protocol]{protocol} is defined in the natural way: 
Alice and Bob apply their strategies to their local strings, yielding two vectors, 
and the output of the protocol is obtained using the output map. 
As usual, we require split invariance, i.e.~the output of the protocol should
depend only on the input string $w$ and not on its factorisation $w = w_1 w_2$.

% Before continuing with the proof, let us briefly use explain why we chose to work with bilinear maps instead of scalar products.
% First, let us observe that scalar products can be defined in the orbit-finite in a natural way:
% \begin{align*}
% \langle v, w \rangle = \sum_{q} (\text{coefficient of $q$ in $v$}) \cdot ( \text{coefficient of $q$ in $w$}),
% \end{align*}
% where the sum ranges over basis vectors. Observe that this sum is in fact finite, since each of the vectors $v$ and $w$ involves only finitely many basis vectors with non-zero coefficients.
% Scalar products are a special case of bilinear maps, and therefore every scalar product protocol is a special case of a bilinear protocol. In the finite case it is easy to show
% directly that bilinear protocols are equivalent to scalar product protocols. In the orbit-finite case the picture is a bit more complex, the two models are still equivalent,
% but we are no aware of a direct proof -- the equivalence follows from the fact that both models are equivalent to weighted orbit-finite automata as we will show later in this section.

Let us go back to the proof of \cref{thm:orbit-finite-protocol-to-weighted}. The proof has two steps, as described in the following diagram.
\[
\begin{tikzcd}
\text{orbit-finite protocol}
\ar[d,Rightarrow,"\text{Lemma~\ref{lem:orbit-finite-protocol-to-scalar}}"]
\\
\text{orbit-finite bilinear protocol}
\ar[d,Rightarrow, "\text{\cref{claim:bilinear-prot-to-of-automaton}}"]
\\
\text{orbit-finite weighted automaton}
\end{tikzcd}
\]

We begin with the first step, which can be seen as form of reduction to one round. Recall that without vector spaces, a reduction to one round was not possible, see Example~\ref{ex:no-one-round-reduction}. This phenomenon is connected to closure under taking function spaces: orbit-finite sets are not closed under taking function spaces, but this closure is recovered once one moves to vector spaces, see~\cite[Section 8.3]{bojanczyk_slightly}. 

\alc{orbit finite bilinear protocol should probably be used here instead of 
orbit finite scalar product protocol}
\begin{lemma}\label{lem:orbit-finite-protocol-to-scalar}
  If $L \subseteq \Sigma^*$ is computed by an \kl{orbit-finite protocol}, then its characteristic function is computed by an \kl{orbit-finite bilinear product protocol}, over any field.
\end{lemma}


\begin{proof}
  \AP
    We first introduce a common generalisation of the two models called \intro{hybrid protocols}. 
    In such a protocol, there are multiple rounds of messages, 
    followed by a bilinear operation. We will show that the multiple rounds can be eliminated,
    yielding a plain \kl{orbit-finite bilinear protocol}.
    
    Here is the formal definition of the \kl{hybrid protocol}:
    For each round $i \in \set{1, \ldots, k-1}$, the parties exchange messages just as in an 
    \kl[of protocol]{orbit-finite protocol} from Definition~\ref{def:orbit-finite-protocol}, 
    using message spaces $Q_A$ and $Q_B$ and strategies of the following types: 
        \begin{align*}
        \sigma_{A,i} & : \Sigma^* \times (Q_B)^{i-1} \to Q_A\\
        \sigma_{B,i} & : \Sigma^* \times (Q_A)^{i-1} \to Q_B
        \end{align*}
    Then, in  the last $k$-th round, the message histories are used to produce vectors 
    in two \kl[ofd vector spaces]{vector spaces} $V_A$ and $V_B$ of orbit-finite dimension, 
    see Definition~\ref{def:orbit-finite-vector-space}, using strategies 
    of types
    \begin{align*}
        \sigma_{A,k} & : \Sigma^* \times (Q_B)^{k-1} \to V_A\\
        \sigma_{B,k} & : \Sigma^* \times (Q_A)^{k-1} \to V_B.
        \end{align*}
    Finally, from the two vectors, the output is computed using a bilinear map
    \begin{align*}
        \text{out} : V_A \times V_B \to \domain.
    \end{align*}
    

    The hybrid protocol generalises both \kl{orbit-finite protocols} and 
    \kl{orbit-finite bilinear protocols}. 
    For the latter, this is clear: we simply use $k=1$ and there is no message exchange. 
    For the former, we proceed as follows.
    We use  trivial vector spaces, i.e.~both $V_A$ and $V_B$ are the field. 
    The bilinear map is multiplication. 
    Once the two parties have agreed on a Boolean decision, 
    they can both send $1$ (in the case of a ``yes'' decision) or $0$ (in the case of a ``no'' decision), 
    and the bilinear map will give the correct output. 
    
    In order to complete the proof of the lemma, we will show that the number
    of rounds can always be reduced to one, thus yielding a \kl[of bilinear protocol]{bilinear protocol}.

    \begin{claim}\label{claim:reduce-round}
      For every $k > 1$, a \kl{hybrid protocol} with $k$ rounds can be simulated by a 
      \kl{hybrid protocol} with $k-1$ rounds.
    \end{claim}
    \begin{proof}
        We will eliminate round $k-1$, where the last message is sent. 
        Once Alice has received the first $k-2$ messages from Bob, 
        her contribution to the rest of the protocol is described by an object of type 
          \begin{align}\label{eq:contribution-last-two-rounds}
            \myunderbrace{Q_A}{message \\ sent in \\ round $k-1$} \quad \times \quad  \myunderbrace{(\fsfun  {Q_B} {V_A})}{message sent in \\ round $k$, as a function \\ of the message sent \\ in  round $k-1$}
        \end{align}
        We want to turn the above type into a vector space. 
        The second coordinate is already a vector space, since functions with outputs in a vector space can be added and scaled pointwise. What is more, the  second coordinate  is  a \kl{vector space of orbit-finite dimension}, which is a nontrivial result~\cite[Theorem 8.16]{bojanczyk_slightly}, i.e.~it has an orbit-finite basis  
        \begin{align*}
        F_A \subseteq \fsfun  {Q_B} {V_A}.  
        \end{align*}
        \rs{expand what is the cited theorem and how it is applied}
        The first coordinate $Q_A$ in~\eqref{eq:contribution-last-two-rounds} can be turned into a vector space by  allowing linear combinations, i.e.~$\lincomb Q_A$. We combine these two using tensor product, yielding a vector space of orbit-finite dimension
        \begin{align*}
           W_A =  (\lincomb Q_A) \otimes (\lincomb F_A).
        \end{align*}
        We can do the same thing for Bob, obtaining a vector space
        \begin{align*}
           W_B =  (\lincomb Q_B) \otimes (\lincomb F_B),
        \end{align*}
        where $F_B$ is an orbit-finite basis of the vector space $\fsfun  {Q_A} {V_B}$.
        In order to define an equivariant bilinear map of type
        \begin{align*}
        \varphi : W_A \times W_B \to \domain
        \end{align*}
        it is enough to define an equivariant linear map of type 
        \begin{align*}
        \varphi : W_A \otimes W_B \to \domain
        \end{align*}
        for which it is enough to define an equivariant function on its basis
        \begin{align*}
        Q_A \times F_B \times Q_B \times F_A \to \domain
        \end{align*}
        This definition is the only one that types, namely 
        \begin{align*}
        (q_A, f_B, q_B, f_A) \quad 
        \mapsto \quad 
        \text{out}(f_A(q_B), f_B(q_A)).
        \end{align*}
        Because the output map is bilinear, one can check that $\varphi$ defined this way is consistent with the original protocol, i.e.~if we take functions 
        \begin{align*}
        f_A : Q_B \to V_A \qquad \text{and} \qquad f_B : Q_A \to V_B,
        \end{align*}
        which are not necessarily basis vectors from $F_A$ and $F_B$, then we have 
        \begin{align*}
        \text{out}(f_A(q_B), f_B(q_A)) = \varphi((q_A, f_B), (q_B, f_A)).
        \end{align*}
        Therefore, we can implement the last two round of the original hybrid protocol using a single round. The message spaces and the strategies for the first $k-2$ rounds are unchanged. In the last round $k-1$, the new strategies
        \begin{align*}
        \sigma'_{A,k-1} & : \Sigma^* \times (Q_B)^{k-2} \to W_A\\
        \sigma'_{B,k-1} & : \Sigma^* \times (Q_A)^{k-2} \to W_B
        \end{align*}
        output the tensor pairs consisting of the contribution that was described in~\eqref{eq:contribution-last-two-rounds}. Finally, the output  map for the new protocol is $\varphi$. 
    \end{proof}

    By repeatedly applying the above claim, we can reduce the number of rounds to one, in which case we get a bilinear protocol, as required in the statement of the lemma. 
\end{proof}


\subsubsection{Orbit-Finite Fliess Theorem}
In this section, we prove an orbit-finite version of the Fliess Theorem, which characterises functions $\Sigma^* \to \domain$ that are computed by \kl{weighted orbit-finite automata}. 
This result will be used to complete the proof of \cref{thm:orbit-finite-protocol-to-weighted}.

As in the original Fliess Theorem, we will be interested in \kl{derivatives} of the function,
which live in the space  
\begin{align*}
\Sigma^* \to \domain.
\end{align*}
This space has three kinds of structure, all of which will are used in the Fliess Theorem: 
\begin{enumerate}
    \item It is a vector space, since we can take linear combinations of functions.
    \item It has a notion of \kl{left derivatives}, i.e.~for each function $f$ and input string $w \in \Sigma^*$, we can consider the \kl{left derivative} $v \mapsto f(wv)$, which is denoted by $\leftderivative{f}{w}$.
    \item It has a notion of \kl{atom permutations}: for each function $f$ and atom permutation $\pi$, we can consider the function $\pi(f)$, which is the composition $\pi;f$.
\end{enumerate}

\AP
We say that a subset  $U \subseteq \Sigma^* \to \domain$  is
\intro{orbit-finitely spanned} if there is some \kl{orbit-finite} set $Q$, such that
every element of $U$ is a finite linear combination of elements from $Q$. We do
not require the linear combination to be unique, i.e.~we do not require $Q$ to
be a basis. (Choosing a basis can be problematic in the context of orbit-finite
sets, see~\cite[Example 77]{bojanczyk_slightly}.) We are now ready to state the
orbit-finite version of the Fliess Theorem.

\begin{theorem}[Orbit-Finite Fliess Theorem]\label{thm:orbit-finite-fliess}
    The following two conditions are equivalent for every function
    $f : \Sigma^* \to \domain$
    where $\Sigma$ is an orbit-finite alphabet and $\domain$ is a field.
    \begin{enumerate}
      \item \label{it:fliess-weighted} $f$ is computed by a \kl{weighted orbit-finite automaton};
      \item \label{it:fliess-derivatives} $f$ is \kl{equivariant} and its set of
        \kl{left derivatives} is \kl{orbit-finitely spanned}.
        %  there is a finite set $\Gamma$ of derivatives of $f$, such that every derivative of $f$ can be expressed as linear combination
        % \begin{align*}
        % \alpha_1 \pi_1(f_1) + \cdots + \alpha_k \pi_k(f_k),
        % \end{align*}
        % where each $\alpha_i$ is in the field, each $\pi_i$ is an atom permutation, and each $f_i$ is in $\Gamma$.
    \end{enumerate}
\end{theorem}
\begin{proof} Our proof follows the lines of the original theorem, without any significant changes.

    \AP
    We begin with the implication \ref{it:fliess-weighted} $\implies$ \ref{it:fliess-derivatives}. Consider a weighted orbit-finite automaton with state space $Q$. 
    Define the \intro{pre-weight} of a run in the same way as its weight, except that we do not use the final weight. In other words, this is the product of: (1) the initial weight of the first state; and (2) the weights of all transitions. Consider an input string $w$. Define the \intro{configuration} of $w$ to be the linear combination
    \begin{align}
        \label{eq:configuration-wa}
        \sum_\rho \alpha_\rho \cdot q_\rho,
    \end{align}
    where $\rho$ ranges over runs that have input $w$ and non-zero \kl{pre-weight},
    $\alpha_\rho$ is the \kl{pre-weight} of the run $\rho$, and $q_\rho$ is the last state in this run.
    By the assumption that each input string has finitely many runs with non-zero weight, 
    the configuration is a finite sum, i.e.~it belongs to the vector space $\lincomb Q$. 
    The \kl{left derivative} which corresponds to the input string is uniquely determined 
    by this configuration, and the space of \kl{configurations} is \kl{orbit-finitely spanned}. 
    Hence, we get~\ref{it:fliess-derivatives}.

    We now prove the other implication, \ref{it:fliess-derivatives} $\implies$
    \ref{it:fliess-weighted}. Assume~\ref{it:fliess-weighted}, which means that
    there is an \kl{orbit-finite} set $Q \subseteq \Sigma^*$ such that every
    \kl{derivative} of $f$ can be decomposed as a finite linear combination of left
    derivatives
    \begin{align*}
            \sum_i \alpha_i \leftderivative{f}{w_i},
    \end{align*}
    where each string $w_i$ is in $Q$. The following claim shows that strings obtained by taking elements of $Q$ and appending one letter
    (i.e. strings of the form $Q \cdot \Sigma$) can be decomposed in an equivariant way:
    \begin{claim}
      There is an \kl{equivariant function}
        \begin{align*}
       \delta :  Q \times \Sigma \to \lincomb Q
        \end{align*}
        such that the following conditions holds for every $w \in Q$ and $a \in \Sigma$:
        \begin{align*}
        \delta(w,a) = 
        \sum_i \alpha_i w_i 
        \qquad \Rightarrow \qquad 
        \leftderivative f {wa} = \sum_i \alpha_i \leftderivative{f}{w_i}.
        \end{align*}
    \end{claim}
    \begin{proof}
        Observe that Condition~\ref{it:fliess-derivatives} in the theorem's statement already asserts that there exists such a function $\delta$,
        possibly non-equivariant. In this proof we show how to modify it so that it becomes equivariant
        while still satisfying other requirements of the claim. We construct this modified function $\delta'$ as follows:
        for every orbit $Q \times \Sigma$ pick its representative $(w, a)$ and then extend the result to the whole orbit by equivariance:
        \begin{align*}
        \delta'(\pi(w), \pi(a)) := \pi(\delta(w, a))
        \end{align*}
        The new function $\delta'$ is equivariant by construction, and it keeps satisfying other requirements of the claim because
        $f$ is an equivariant function, so its derivatives commute with atom permutation:
        \begin{align*}
        \leftderivative{f}{\pi(w)}= \pi(\leftderivative{f}{w}).
        \end{align*}
        This gives  us that:
        \begin{align*}
                    \leftderivative{f}{wa} = \sum_i \alpha_i \leftderivative{f}{w_i}
                    \quad \iff \quad 
                            \leftderivative{f}{\pi(wa)} = \sum_i \alpha_i \leftderivative{f}{\pi(w_i)},
        \end{align*}
        which completes the proof of the claim.
    \end{proof}        

    Using the function $\delta$ from the above claim, we define a \kl{weighted
    orbit-finite automaton}. The state space is the set $Q$. (We assume without
    loss of generality that $Q$ contains the empty string $\varepsilon$. This
    is not really necessary for the construction, but it makes it more
    intuitive.) The weights are defined as follows: 
    \begin{itemize}
        \item \textbf{Initial weights.} The initial weight of   $\varepsilon$ is $1$. All other states have initial weight $0$.
        \item \textbf{Transition weights.} The weight of a transition 
        \begin{align*}
        w \xrightarrow{a} v
        \end{align*}
    is the coefficient next $v$ in the linear decomposition $\delta(w,a)$.
        \item \textbf{Final weights.} The final weight of a state $w \in Q$ is $f(w)$.
    \end{itemize}
    Remember that \kl{orbit-finite weighted automata} can only admit finitely many runs for each input word.
    Our automaton satisfies this requirement, as all linear combinations returned by $\delta$ are finite. 

    Finally, we justify why this automaton computes the function $f$. A simple inductive proof shows that  
    \begin{align*}
\text{configuration of $w$} = \sum_\rho \alpha_\rho \cdot w_\rho
\quad \implies \quad 
        \leftderivative f w = 
    \sum_\rho \alpha_\rho \cdot \leftderivative f {w_\rho}.
    \end{align*}
    By choice of final weights, the output of the automaton is equal to $f(w)$. 
\end{proof}

We are now ready to complete the proof of \cref{thm:orbit-finite-protocol-to-weighted} by showing the missing link:
\begin{claim}
\label{claim:bilinear-prot-to-of-automaton}
Let $\domain$ be a field.
    If a function $\Sigma^* \to \domain$ is computed by an 
    \kl{orbit-finite bilinear protocol}, it can also be computed by an 
    \kl{orbit-finite weighted automaton}.
\end{claim}
\begin{proof}
    Thanks to the Orbit-Finite Fliess Theorem,
    it is enough to show that if a function is computed by an \kl{orbit-finite bilinear 
    protocol}, then it has an \kl{orbit-finitely spanned vector space} of \kl{left derivatives}. This follows from the same argument as in Section~\ref{sec:field-domain}:
    the vector produced by Alice in a \kl[of bilinear protocol]{bilinear protocol}
    uniquely determines the \kl{left derivative} of her part of the input. 
\end{proof}
