\section{Sequential Protocols}

\begin{definition}
    \label{Sequential-Protocols}
A sequential protocol over a monoid is a simple-aggregation protocol (as defined in Definition~\ref{simple-aggregation-definition}) such that the signal space of Bob, $Q_B$, is a singleton set. In other words, there is no communication from Bob to Alice, and only Alice can send signals to Bob. Such a protocol is therefore specified by: $f_A: \Sigma^* \to M$ and $q_A: \Sigma^* \to Q_A$ for Alice, and $f_B: \Sigma^* \times Q_A \to M$ for Bob. The final output on inputs $x,y$ is $f_A(x)\ast f_B(y, q_A(x))$.
\end{definition}

\begin{myexample}
    \label{example-sequential-protocol}
Let $TM_1,TM_2, \ldots$ be an enumeration of all Turing transducers. Consider the sequential protocol over the monoid $(\mathbb{N}, +, 0)$ where Alice's functions are defined as $f_A(x) = |x|$ and $q_A(x) = 1$ if $TM_{|x|}$ halts on input $  x $ and $f_A(x) =|x| + 1$ and $q_A(x) = 2$ otherwise. Bob's function is defined as $f_B(y, q_A(x)) = |y|+1$ if $q_A(x) = 1$ and $f_B(y, q_A(x)) = |y|$ if $q_A(x) = 2$.

Observe that the output of this protocol is always $|x| + |y| + 1 = |xy|+1$, regardless of whether $TM_{|x|}$ halts on input $ x $ or not. Therefore, the split-invariance condition is satisfied. 

\end{myexample}

\begin{corollary}
    \label{corollary-sequential-protocols}
    The above example shows that signal functions in sequential protocols and more generally in simple-aggregation protocols can be uncomputable functions. 
\end{corollary}

\begin{lemma}
    \label{prefix-lemma-sequential-protocols}
Let $(f_A,f_B,Q_A,Q_B,q_A)$ be ingridients of a sequential protocol over the monoid $(\Gamma^*, \cdot, \varepsilon)$. Now for any two string $w_1, w_2 \in \Sigma^*$, if $q_A(w_1) = q_A(w_1w_2)$ then $f_A(w_1)$ is a prefix of $f_A(w_1w_2)$. More percisely, there exists a string $u \in \Gamma^*$ (output domain) such that $f_A(w_1w_2) = f_A(w_1) \cdot u$. In another words, Alice's local output grows monotonically with respect to the prefix order on strings, whenever the signal sent to Bob does not change.
\end{lemma}

\begin{proof}
    
Assume towards a contradiction that $q_A(w_1) = q_A(w_1 w_2)$ but $f_A(w_1)$ is \emph{not} a prefix of $f_A(w_1 w_2)$. Let $q = q_A(w_1) = q_A(w_1 w_2)$. Then:
\begin{equation}
    f(w_1 w_2)
    = f_A(w_1)\, f_B(w_2,q)
    = f_A(w_1 w_2)\, f_B(\varepsilon,q)
    \label{eq:seq1}
\end{equation}
Since $f_A(w_1)$ is not prefix of $f_A(w_1w_2)$ by assumption, Equation~\eqref{eq:seq1} implies that $f_A(w_1w_2)$ is a strict prefix of $f_A(w_1)$. Write
\[
f_A(w_1) = f_A(w_1 w_2)\, v
\]
for some nonempty $v \in \Gamma^*$. Let
\[
u = f_A(w_1 w_2), \qquad z_1 = f_B(w_2,q)
\]
Then \eqref{eq:seq1} yields
\[
f_B(\varepsilon,q) = v z_1
\]
Now consider $w_1 w_2^2$. Using split-invariance,
\begin{equation}
    f(w_1 w_2^2)
    = f_A(w_1)\, f_B(w_2^2,q)
    = f_A(w_1 w_2)\, f_B(w_2,q)
    \label{eq:seq2}
\end{equation}
Let $z_2 = f_B(w_2^2,q)$. Substituting $f_A(w_1) = u v$ and $f_A(w_1 w_2) = u$ into \eqref{eq:seq2} gives
\[
u v z_2 = u z_1 \quad \Rightarrow \quad v\,z_2 = z_1
\]
Repeating this argument inductively, define
\[
z_k = f_B(w_2^k,q).
\]
The same cancellation shows
\[
z_k = v\,z_{k+1} \qquad \text{for all } k \ge 0
\]
Now since $v \neq \varepsilon$, the length of $z_k$ strictly decreases with $k$. This yields a contradiction.
\end{proof}

%====
\begin{corollary}
If for $w_1,w_2\in\Sigma^*$ we have $q_A(w_1)=q_A(w_1w_2)=:q$, then
\[
   f(w_1)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
   \text{ is a prefix of }
   f(w_1w_2)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
\]
Equivalently, there exists a string $u\in\Gamma^*$ such that
\[
   f(w_1w_2)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
   \;=\;
   f(w_1)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}\cdot u
\]
\end{corollary}

\begin{proof}
For $q = q_A(w_1)=q_A(w_1w_2)$ we have, by definition of the global output of a sequential protocol:
\[
   f(w_1)=f_A(w_1)\,f_B(\varepsilon,q), \qquad
   f(w_1w_2)=f_A(w_1w_2)\,f_B(\varepsilon,q)
\]
By Lemma~\ref{prefix-lemma-sequential-protocols}, the assumption
$q_A(w_1)=q_A(w_1w_2)$ implies that $f_A(w_1)$ is a prefix of $f_A(w_1w_2)$.
Hence there exists $u\in\Gamma^*$ such that
\[
   f_A(w_1w_2)=f_A(w_1)\,u
\]
Substituting this expression into the global output gives
\[
   f(w_1w_2)=f_A(w_1)\,u\,f_B(\varepsilon,q)
            = \bigl(f_A(w_1)\,f_B(\varepsilon,q)\bigr)\,u
            = f(w_1)\,u
\]
Right-cancelling the common suffix $f_B(\varepsilon,q)$ yields
\[
   f(w_1w_2)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
   \;=\;
   f(w_1)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}\cdot u
\]
which proves that
\[
   f(w_1)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
   \preceq
   f(w_1w_2)\cdot \bigl(f_B(\varepsilon,q)\bigr)^{-1}
\]
\end{proof}

The above lemma and corollary was not used in the rest of the paper, but is included here as it may be of independent interest.
%====

Before stating the main theorem of this section, to avoid any ambiguity, we will use the definition of subsequential transducers as given in \cite{reutenauer1990subsequential}.

\begin{theorem}
    \label{theorem-main-sequential-protocol}
    For every sequential protocol over the monoid $(\Gamma^*, \cdot, \varepsilon)$, there exists a subsequential transducer that computes the same function.
\end{theorem}

\begin{proof}

        For every function $f: \Sigma^* \to \Gamma^*$ we will define $\widehat{f}: \Sigma^* \to \Gamma^*$ as follows:
        \[
        \widehat{f}(w) = lcp\{ f(wv) : v \in \Sigma^* \}
        \]
        where $lcp$ stands for longest common prefix.
        \begin{definition}
            \label{definition-finitely-many-derivatives}

            Suppose that a function $f: \Sigma^* \to \Gamma^*$ satisfies the property that for every $w_1, w_2 \in \Sigma^*$, $\widehat{f}(w_1)$ is a prefix of $f(w_1 w_2)$. Then we can define the \emph{derivative} of $f$ at $w \in \Sigma^*$ as the function $f_w: \Sigma^* \to \Gamma^*$ defined by:
            \[f_w(v) = \widehat{f}(w)^{-1} f(wv)\]
            for every $v \in \Sigma^*$. And we say that $f$ has \emph{finitely many derivatives} if the set $\{ f_w : w \in \Sigma^* \}$ is finite.

        \end{definition}
        

        Let $(f_A,f_B,Q_A,q_A)$ be the ingredients of a sequential protocol over the monoid $(\Gamma^*, \cdot, \varepsilon)$. Consider the function $f: \Sigma^* \to \Gamma^*$ defined by the sequential protocol, i.e. $f(w) = f_A(w) f_B(\varepsilon, q_A(w))$. First we will show that the function $f$ satisfies the property which is required in Definition~\ref{definition-finitely-many-derivatives}. Then we will show that $f$ has finitely many derivatives, or more precisely, we will show that for every $w_1, w_2 \in \Sigma^*$ such that $q_A(w_1) = q_A(w_2)$, it holds that $f_{w_1} = f_{w_2}$. This will imply that the number of distinct derivatives of $f$ is at most $|Q_A|$, which is finite.

        \noindent
        First define the function $\widehat{u}: Q_A \to \Gamma^*$ as follows:
        \[\widehat{u}(q) = lcp\{ u \in \Sigma^* : u \text{ is a prefix of } f_B(v,q) \text{ for all } v \in \Sigma^* \}\]
        that is, $\widehat{u}(q)$ is the longest common prefix of the strings $f_B(v,q)$ for all $v \in \Sigma^*$. Now we will show that for every $w \in \Sigma^*$, $\widehat{f}(w) = f_A(w) \cdot \widehat{u}(q_A(w))$. Observe that $f_A(w)$ is always a prefix of $f(w \cdot v)$ for any $v \in \Sigma^*$, since:
        \[f(w \cdot v) = f_A(w) \cdot f_B(v,q_A(w))\]
        Thus, there exists a string $u \in \Sigma^*$ such that $\widehat{f}(w) = f_A(w) \cdot u$. By construction, $ \widehat{u}(q_A(w)) $ is a prefix of $ f_B(v,q_A(w)) $ for all $ v \in \Sigma^* $. Therefore, $ f_A(w) \cdot \widehat{u}(q_A(w)) $ is a prefix of $\widehat{f}(w)$. Now it is enough to show that $\widehat{f}(w)$ can not be strictly longer than $ f_A(w) \cdot \widehat{u}(q_A(w)) $. Assume by contradiction that $\widehat{f}(w)$ is strictly longer than $ f_A(w) \cdot \widehat{u}(q_A(w)) $.  Then, there exists a string $u' \in \Sigma^*$ such that $\widehat{f}(w) = f_A(w) \cdot \widehat{u}(q_A(w)) \cdot u'$, with $u' \neq \varepsilon$. By definition of $\widehat{f}$, for any $ v \in \Sigma^* $, $ f_A(w) \cdot \widehat{u}(q_A(w)) \cdot u' $ is a prefix of $ f(w \cdot v) = f_A(w) \cdot f_B(v,q_A(w)) $. Therefore, $\widehat{u}(q_A(w)) \cdot u' $ is a prefix of $ f_B(v,q_A(w)) $ for all $ v \in \Sigma^* $. This contradicts the definition of $ \widehat{u}(q_A(w)) $ as the longest common prefix of the strings $ f_B(v,q_A(w)) $ for all $ v \in \Sigma^* $. Hence, $\widehat{f}(w) = f_A(w) \cdot \widehat{u}(q_A(w))$.


        Now consider two function $f_{w_1}$ and $f_{w_2}$ for some $w_1, w_2 \in \Sigma^*$ such that $q_A(w_1) = q_A(w_2)$. We will show that $f_{w_1} = f_{w_2}$.
        To be more precise, we will show that for every string $w \in \Sigma^*$, $f_w$ is the function that maps any $v \in \Sigma^*$ to $\widehat{u}(q_A(w))^{-1} f_B(v, q_A(w))$. This is because for any $ v \in \Sigma^* $ we have:
        \begin{align*}
        f_w(v) &= \widehat{f}(w)^{-1} \cdot f(wv)\\
        &= (f_A(w) \cdot \widehat{u}(q_A(w)))^{-1} \cdot (f_A(w) \cdot f_B(v,q_A(w)))\\
        &= \widehat{u}(q_A(w))^{-1} \cdot f_B(v,q_A(w))
        \end{align*}
        Therefore, for any $w_1, w_2 \in \Sigma^*$ such that $q_A(w_1) = q_A(w_2)$, it holds that $f_{w_1} = f_{w_2}$. Observe that the number of distinct functions $f_w$ is at most $|Q_A|$, but can be strictly less. Therefore it is possible that for some $q_1, q_2 \in Q_A$ with $q_1 \neq q_2$, it holds that $f_{w_1} = f_{w_2}$. But in any case, the number of distinct derivatives of $f$ is at most $|Q_A|$, which is finite. Hence, $f$ has finitely many derivatives. \footnote{This theorem was proved in collaboration with Thomas Filasto.}
    
    \begin{theorem}
        \label{theorem-subsequential-transducer}
         A function $f: \Sigma^* \to \Gamma^*$ can be computed by a subsequential transducer if and only if it has finitely many derivatives (as defined in Definition~\ref{definition-finitely-many-derivatives}). 
    \end{theorem}
    \noindent
    Also the proof can be found in \cite{reutenauer1990subsequential} (see Theorem 1), I include it here because it is essential for the next steps.
    \begin{proof}
    Let $ u,v \in \Sigma^* $, we start by showing the following equality:
    \begin{equation}
        \label{congruence-equation-derivatives}
        \widehat{f}(uv) = \widehat{f}(u) \cdot \widehat{f_u}(v)
    \end{equation}
    
    \begin{align*}
    \widehat{f}(uv) &= lcp \lbrace f(uvw) \mid w \in \Sigma^* \rbrace\\
    &= lcp \lbrace \widehat{f}(u) \cdot f_u(vw) \mid w \in \Sigma^* \rbrace &(f_u(vw) = \widehat{f}(u)^{-1} \cdot f(uvw))\\
    &= \widehat{f}(u) \cdot lcp \lbrace f_u(vw) \mid w \in \Sigma^* \rbrace\\
    &= \widehat{f}(u) \cdot \widehat{f_u}(v)
    \end{align*}
    Now, we will show that $ f_{u v} = (f_u)_v $. Let $ w \in \Sigma^* $, we have:
    \begin{align*}
    f_{u v}(w) &= \widehat{f}(uv)^{-1} \cdot f(uvw)\\
    &=(\widehat{f}(u) \cdot \widehat{f_u}(v))^{-1} \cdot f(uvw) &\text{(by Equation \ref{congruence-equation-derivatives})}\\ 
    &=(\widehat{f}(u) \cdot \widehat{f_u}(v))^{-1} \cdot (\widehat{f}(u) \cdot f_u(vw)) &(f_u(vw) = \widehat{f}(u)^{-1} \cdot f(uvw))\\
    &=(\widehat{f}(u) \cdot \widehat{f_u}(v))^{-1} \cdot (\widehat{f}(u) \cdot (\widehat{f}_u(v) \cdot (f_u)_v(w))) &((f_u)_v(w) = \widehat{f}_u(v)^{-1} \cdot f_u(vw))\\
    &= (f_u)_v(w)
    \end{align*}
    Now Let $ w,w' \in \Sigma^* $ such that $ f_w = f_{w'} $, then for any $ v \in \Sigma^* $, the following equality holds:
    \begin{equation}
    \label{equation-derivative-equivalence}
    f_w = f_{w'} \implies f_{wv} = f_{w'v}
    \end{equation}
    This is because:
    \begin{align*}
    f_{wv} &= (f_w)_v &(f_{uv} = (f_u)_v)\\
    &= (f_{w'})_v &(f_w = f_{w'})\\
    f_{wv} &= f_{w'v} &(f_{uv} = (f_u)_v)
    \end{align*}
    
    From the above formulae, one can construct a subsequential transducer that computes the same function as $ f $. The states of the transducer are the distinct derivatives of $ f $, i.e. $ Q = \lbrace f_w \mid w \in \Sigma^* \rbrace $. The initial state is $ f_{\varepsilon} $. The state-transition function $ \delta: Q \times \Sigma \to Q $ is defined as follows: for any $ f_w \in Q $ and $ a \in \Sigma $, $ \delta(f_w,a) = f_{wa} $. The output function $ \lambda: Q \times \Sigma \to \Gamma^* $ is defined as follows: for any $ f_w \in Q $ and $ a \in \Sigma $, $ \lambda(f_w,a) = \widehat{f_w}(a) $. Finally, the terminal output function $ t: Q \to \Gamma^* $ is defined as follows: for any $ f_w \in Q $, $ t(f_w) = \widehat{f}(w)^{-1} f(w) $. Having the above formulae in mind, one can verify that the constructed subsequential transducer computes the same function as $ f $.
    \end{proof}
    \noindent
    This completes the proof of the main theorem of this section.
\end{proof}

%==== Normalized Sequential Protocols 
To have a clean characterization of class of protocols, we like to have some kind of normalization for each one of them to avoid unwanted behaviors such as the one shown in Example~\ref{example-sequential-protocol}. We think that if the signal functions of a protocol are computable by some simple computational model, then the protocol is more well-behaved. If we want to unwrap this idea further, let first call this simple computational model $\mathcal{M}$. Then, we can roughly say that if the signal functions of a protocol are computable by $\mathcal{M}$, then we expect that Alice output functions will be computable by some relevent computational model (by relevant we mean a model that is equivalent to the class of protocols we are looking at).

Therefore, we will define normalization for each class of protocols based on the computability of their signal functions. To be more specific, we want to have a signal function that is computable by a Deterministic Finite Semi-Automaton (DFSA). Of course, by theorem~\ref{theorem-subsequential-transducer}, having a regular signal function is immidiate. It is because for any sequential protocol one can construct a subsequential transducer that computes the same function, and the state-transition function of a subsequential transducer is computable by a Deterministic Finite Semi-Automaton. But I think looking into normalization process independently is interesting and may help us in defining normalization for more expressive classes of protocols in the future.
\begin{definition}
    \label{definition-normalized-sequential-protocol}
    A sequential protocol $(f_A,f_B,Q_A,q_A)$ over the monoid $(\Gamma^*, \cdot, \varepsilon)$ is called \emph{normalized} if there exists a Deterministic Finite Semi-Automaton $\mathcal{A} = (Q_A, \Sigma, \delta, q_{A_0})$ such that for every $ w \in \Sigma^* $, $ q_A(w) = \delta^*(q_{A_0}, w) $, where $\delta^*$ is the extended transition function of $\mathcal{A}$.
\end{definition}
\begin{theorem}
    \label{theorem-normalized-sequential-protocol}
    For every sequential protocol over the monoid $(\Gamma^*, \cdot, \varepsilon)$, there exists a normalized sequential protocol that computes the same function.
\end{theorem}
\begin{proof}
    Let $(f_A,f_B,Q_A,q_A)$ be the ingredients of a sequential protocol over the monoid $(\Gamma^*, \cdot, \varepsilon)$. We will first construct another protocol $(f_A',f_B',Q_A,q_A)$ that computes the same function as $(f_A,f_B,Q_A,q_A)$ such that the alice output function $f_A'$ is exactly $\widehat{f}$ as defined in the proof of theorem~\ref{theorem-subsequential-transducer}. Then we will show that $(f_A',f_B',Q_A,q_A)$ can be normalized.

    Observe that because alice can compute $q_A$, she can also compute $\widehat{u}$ as defined in the proof of theorem~\ref{theorem-subsequential-transducer}. Therefore, she can compute $\widehat{f}$ as well. Now define the functions $f_A', f_B'$ as follows:
    \[f_A'(w) = \widehat{f}(w)\]
    \[f_B'(w,q) = \widehat{u}(q)^{-1} f_B(w,q)\]
    for every $ w \in \Sigma^* $ and $ q \in Q_A $. It is easy to see that the sequential protocol $(f_A',f_B',Q_A,q_A)$ computes the same function as $(f_A,f_B,Q_A,q_A)$. Now we will define an equivalence relation on Alice's signal space $Q_A$ as follows: First because we know that every signal $ q \in Q_A $ is reachable by some input string we can choose one string $ w_q \in \Sigma^* $ such that $ q_A(w_q) = q $ for every $ q \in Q_A $. Now we define the equivalence relation $\equiv$ on $Q_A$ as follows:
    \[q_1 \equiv q_2 \iff f_{w_{q_1}} = f_{w_{q_2}}\]
    for every $q_1, q_2 \in Q_A $. It is easy to see that $\equiv$ is indeed an equivalence relation. Now we will show that signals that are equivalent under $\equiv$ behave the same under any input string from bob's side. Let $w$ be an arbitrary string in $\Sigma^*$ and let $q_1, q_2 \in Q_A$ such that $q_1 \equiv q_2$. We want to show that $f_B'(w,q_1) = f_B'(w,q_2)$. Choose two arbitary strings $w_1, w_2 \in \Sigma^*$ such that $q_A(w_1) = q_1$ and $q_A(w_2) = q_2$. Now if we show that $f_{w_1} = f_{w_2}$ then we are done. This is because $f(w_1 w) = \widehat{f}(w_1) f_B'(w,q_1)$ and $f(w_2 w) = \widehat{f}(w_2) f_B'(w,q_2)$. Therefore $f_B'(w,q_1) = \widehat{f}(w_1)^{-1} f(w_1 w)=f_{w_1}(w)$ and $f_B'(w,q_2) = \widehat{f}(w_2)^{-1} f(w_2 w)=f_{w_2}(w)$. We have shown in \ref{theorem-main-sequential-protocol} that for any $w_1, w_2 \in \Sigma^*$ such that $q_A(w_1) = q_A(w_2)$, it holds that $f_{w_1} = f_{w_2}$. Therefore, $f_{w_1} = f_{w_{q_1}} = f_{w_{q_2}} = f_{w_2}$. Hence, $f_B'(w,q_1) = f_B'(w,q_2)$.

    Now we can define the normalized sequential protocol. Let $Q_A' = Q_A /_{\equiv}$ be the quotient set of $Q_A$ under the equivalence relation $\equiv$, and $q_A': \Sigma^* \to Q_A'$ be defined as follows:
    \[q_A'(w) = [q_A(w)]_{\equiv}\]
    for every $ w \in \Sigma^* $. Then $(f_A',f_B',Q_A',q_A')$ defines a normalized sequential protocol that computes the same function as $(f_A,f_B,Q_A,q_A)$. To show that it is indeed normalized, we need to show that $q_A'$ is indeed regular. This follows from the formulae we have shown in the proof of theorem~\ref{theorem-main-sequential-protocol}, by Myhill-Nerode theorem. More precisely, for any $ w_1, w_2 \in \Sigma^* $, if $ q_A'(w_1) = q_A'(w_2) $, then for every string $ v \in \Sigma^* $, $q_A'(w_1 v) = q_A'(w_2 v)$. This is because $ q_A'(w_1) = q_A'(w_2) $ implies that $ q_A(w_1) \equiv q_A(w_2) $, which in turn implies that $ f_{w_1} = f_{w_2} $. Therefore, by equation~\eqref{equation-derivative-equivalence}, for every string $ v \in \Sigma^* $, $ f_{w_1 v} = f_{w_2 v} $, which implies that $ q_A(w_1 v) \equiv q_A(w_2 v) $, and hence $ q_A'(w_1 v) = q_A'(w_2 v) $. Thus, by Myhill-Nerode theorem, there exists a Deterministic Finite Semi-Automaton that computes $q_A'$. This completes the proof.
\end{proof}

If we look at the process of normalization, we can observe that we simply lift the $\widehat{u}$ function into alice's output function, because it was only dependent on the signal sent to bob and not on the local input of bob. Therefore, if we want to define normalization for more expressive classes of protocols, we can follow the same idea. That is, we can lift the part of the $f_B$ function that is only dependent on the signal sent to bob into alice's output function. This way, we expect that to obtain a normalized protocol more easily. But of course, more investigation is needed to see if this idea works in more expressive classes of protocols. Also it is worth mentioning that in this normalization process, we could define the equivalence relation $\equiv$ differently. In fact, we could define it based on the behavior of bob's output function, or more precisely, we could define it as follows:
\[q_1 \equiv q_2 \iff \forall w \in \Sigma^*, f_B(w,q_1) = f_B(w,q_2)\]
for every $q_1, q_2 \in Q_A $. This way, we can avoid the use of derivatives in the normalization process. This alternative definition of $\equiv$ may be more suitable for more expressive classes of protocols, because in those classes, the concept of derivatives may not be well-defined. In fact bob's output function is exactly $f_w$ when alice has the local input $w$. This is because Alice's output function is $\widehat{f}$, and therefore we have:
\begin{align*}
f(wv) &= f_A'(w) f_B'(v, q_A(w))\\
&= \widehat{f}(w) f_B'(v, q_A(w))
\end{align*}
Thus, $f_B'(v, q_A(w)) = \widehat{f}(w)^{-1} f(wv) = f_w(v)$. Hence, defining $\equiv$ based on the behavior of bob's output function is equivalent to defining it based on the behavior of derivatives in this case. We will explore this alternative definition of normalization in next sections when we look at more expressive classes of protocols.
