\chapter{Aggregator Protocols}

\label{chap:agg-protocols}

In this chapter, we introduce a new class of protocols called \emph{aggregator-protocols}. This is a new way of looking at Alice-Bob protocols. Here we want to look deeply into the way that Alice and Bob "combine" their messages to produce the final output (by message I mean the element of the output domain that each party sends to the other party at each round of communication). The combining operation here again depends on the output domain of the protocol, but in contrast to normal approaches, here we want to focus more on this combining operation and distinguish different types of protocols based on this operation. Let first explain what we mean by aggregator-protocols.

These protocols are similar to normal Alice-Bob protocols, with one key difference: instead of generating partial outputs using messages that contain an element of the output domain, each party has its own local partial output until the end of the communication, and at the end the final output is computed by aggregating these local outputs using a predefined operation.

\begin{myexample}
Consider the following protocol between Alice and Bob. An evil adversary split the input $w\in \Sigma^*$ into two parts $x,y\in \Sigma^*$ such that $w=xy$. Alice receives $x$ and Bob receives $y$. The goal of the protocol is to compute the length of the input string $w$, i.e., $|w|$. The protocol works as follows:
\begin{itemize}
    \item Alice computes the length of her input $|x|$ and keeps it as her local output.
    \item Bob computes the length of his input $|y|$ and keeps it as his local output.
    \item At the end of the communication, both parties send their local outputs to a ``addition-aggregator''. The aggregator computes the final output as $|x| + |y|$.
\end{itemize}
\end{myexample}

We can define different types of aggregator-protocols based on the aggregation operation used to compute the final output from the local outputs of the parties. We have already seen that protocols on the field output domain are equivalent to aggregator-protocols with the scalar product as the aggregation operation. We call these scalar-product protocols. We also mentioned that this is true for every commutative semiring output domain. Also , It is not hard to see that in case of String-output protocols, the aggregation operation is sequence of concatenation. In that case, alice and bob communicating with each other but keep the local output for themselves until the end of the communication, and at the end each of them send $k$ strings to the aggregator, and the aggregator concatenate all the strings in a zig-zag manner to produce the final output string. In the next section, we will define commutative protocols over a monoid domain as another example of aggregator-protocols.

\begin{definition}
    \label{simple-aggregation-definition}
A simple-aggregation protocol over a monoid is given by the following ingredients:
\begin{itemize}
    \item a monoid $(M, \ast, e)$ as the output domain
    \item a number $k \in \mathbb{N}$ of rounds of communication
    \item signal spaces for Alice and Bob, which are the sets $Q_A$ and $Q_B$, respectively
    \item for each round $1 \leq i \leq k$, two strategies:
    \begin{itemize}
        \item Alice's strategy: $\delta_A^i: \Sigma^* \times Q_B^{i-1} \to Q_A$
        \item Bob's strategy: $\delta_B^i: \Sigma^* \times Q_A^{i-1} \to Q_B$
    \end{itemize}
    \item an output function for each party:
    \begin{itemize}
        \item Alice's output function: $f_A: \Sigma^* \times Q_B^k \to M$
        \item Bob's output function: $f_B: \Sigma^* \times Q_A^k \to M$
    \end{itemize}
\end{itemize}
The output of the protocol on inputs $x,y \in \Sigma^*$ is the aggregation of the local outputs of Alice and Bob:
\[
\text{Output}(x,y) = f_A(x, q_B^1, \ldots, q_B^k) \ast f_B(y, q_A^1, \ldots, q_A^k),
\]
where $q_A^i$ and $q_B^i$ are the signals sent by Alice and Bob in round $i$, respectively.
\end{definition}

Here we say that a protocol computes a function $f: \Sigma^* \to M$ if, for every input split $w=xy$, the output of the protocol on inputs $x,y$ equals $f(w)$.


Observe that in simple-aggregation protocols, the parties can simply send each other the sequence of functions $(f_i)_{i=1,2,\dots,k}$ , such that each function $f_i$ is either from $Q_B^{i-1}$ to $Q_A$ or from $Q_A^{i-1}$ to $Q_B$. This sequence of functions can fully describe the behavior of both parties, or in other words, can generate the communication history (which is a sequence of signals).

Hence we can simplify the definition of simple-aggregation protocols in the following way: Alice send one signal to Bob, let call it $q_A(x)$, which is a function from $\Sigma^*$ to $Q_A$ and $x$ is her local input. Similarly, Bob send one signal to Alice, let call it $q_B(y)$, which is a function from $\Sigma^*$ to $Q_B$ and $y$ is his local input. Then both parties compute their local outputs using these functions as follows:
\[\text{Alice's local output} = f_A(x, q_B(y)) \quad , \quad \text{Bob's local output} = f_B(y, q_A(x))\] 
Finally, the aggregator compute the final output as:
\[\text{Output}(x,y) = f_A(x, q_B(y)) \ast f_B(y, q_A(x))\] \footnote{This reminds us of the \emph{Yin-Yang}, so we would like to call this the Yin-Yang protocols. This is because if you consider the local output of Alice as the Yang, then inside it there is the signal from Bob, which is the Yin. Similarly, the local output of Bob is the Yin, which contains the signal from Alice, which is the Yang. Together they form a complete whole. This is just a poetic analogy, but it will be more clear when we look at specific examples of these protocols later in this chapter, more specifically when we make a strong connection between these protocols and rational functions in Section~\ref{sec:monotone-protocols}, As it is known, rational functions can be represented using bimachines, and bimachines itself can be seen as a Yin-Yang computional model.}.

Without loss of generality, we will always assume that all of the elements of the signal spaces $Q_A$ and $Q_B$ are reachable by the respective signal functions $q_A$ and $q_B$. In other words, for every $q_A \in Q_A$, there exists an input string $x \in \Sigma^*$ such that $q_A(x) = q_A$. Similarly, for every $q_B \in Q_B$, there exists an input string $y \in \Sigma^*$ such that $q_B(y) = q_B$.

\begin{definition}
    \label {configuration-definition}
    A configuration of a simple-aggregation protocol over the input space $\Sigma^*$ for each party and input string can be defined as follows: First fixed an enumeration of elements of signal spaces of both parties, i.e., $Q_A = \{q_A^1, q_A^2, \ldots, q_A^{|Q_A|}\}$ and $Q_B = \{q_B^1, q_B^2, \ldots, q_B^{|Q_B|}\}$. Then the configuration of Alice on input $x \in \Sigma^*$ is a vector of size $|Q_B|$ defined as follows:
    \begin{align}
    C_A(x) &= \begin{bmatrix}
           m_{1} \\
           m_{2} \\
           \vdots \\
           m_{|Q_B|}
    \end{bmatrix} \quad \text{where } m_{i} = f_A(x, q_B^i) \quad \text{for } 1 \leq i \leq |Q_B|
    \end{align}
    Similarly, the configuration of Bob on input $y \in \Sigma^*$ can be defined.
\end{definition}

\begin{theorem}
    \label{thm:simple-aggregation-to-normal}
    Suppose that a function $f: \Sigma^* \to M$ is expressible by a normal Alice-Bob protocol over a commutative monoid $(M, \ast, e)$. Then there exists a simple-aggregation protocol that expresses the same function.
\end{theorem}

\begin{proof} 
    We are going to simply simulate the original protocol with a simple-aggregation protocol. In the simulation we replace the operation of combining the messages at each round with signals. Observe that in this setting, there are two kind of messages: the messages that are combinations of previous messages (which we call them \emph{complex terms}), and the messages that are not combinations of previous messages (which we call them \emph{primitive terms}). In the simulation, each signal corresponds to a primitive term is like a pointer to the actual message which the owner at the end of the communication can reconstruct it locally. Now if there exists one signal for each primitive term, which is possible since the number of rounds is finite, then we can have signals for each complex term as well, for the same reason that number of rounds is finite. Now at each round, instead of sending the actual message, each party sends the signal that corresponds to that message. Since the monoid is commutative, the order of combining the messages does not matter, hence alice and bob can simply aggregate their own messages that define the final output locally and send them to the aggregator at the end of the communication.
\end{proof}

\input{signal_free_protocols.tex}
%\input{addition_agg.tex}
\input{Sequential_Protocols.tex}
\input{monotone_protocols.tex}