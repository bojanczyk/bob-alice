\subsection{Commutative Protocols over a Monoid}
\label{sec:commutative-boolean-domain}

\begin{definition}
A simple-aggregation protocol over a monoid is given by the following ingredients:
\begin{itemize}
    \item a monoid $(M, \ast, e)$ as the output domain
    \item a number $k \in \mathbb{N}$ of rounds of communication
    \item signal spaces for Alice and Bob, which are the sets $Q_A$ and $Q_B$, respectively
    \item for each round $1 \leq i \leq k$, two strategies:
    \begin{itemize}
        \item Alice's strategy: $\delta_A^i: \Sigma^* \times Q_B^{i-1} \to Q_A$
        \item Bob's strategy: $\delta_B^i: \Sigma^* \times Q_A^{i-1} \to Q_B$
    \end{itemize}
    \item an output function for each party:
    \begin{itemize}
        \item Alice's output function: $o_A: \Sigma^* \times Q_B^k \to M$
        \item Bob's output function: $o_B: \Sigma^* \times Q_A^k \to M$
    \end{itemize}
\end{itemize}
The output of the protocol on inputs $x,y \in \Sigma^*$ is the aggregation of the local outputs of Alice and Bob:
\[
\text{Output}(x,y) = o_A(x, q_B^1, \ldots, q_B^k) \ast o_B(y, q_A^1, \ldots, q_A^k),
\]
where $q_A^i$ and $q_B^i$ are the signals sent by Alice and Bob in round $i$, respectively.
\end{definition}

Here we say that a protocol computes a function $f: \Sigma^* \to M$ if, for every input split $w=xy$, the output of the protocol on inputs $x,y$ equals $f(w)$.

\begin{definition}
A signal-free simple-aggregation protocol over a monoid is a restriction of simple-aggregation protocols in which the signal spaces $Q_A$ and $Q_B$ are singleton sets. In other words, there is no communication between the parties, and each party computes its local output based only on its input. Such a protocol is therefore specified by:
\begin{itemize}
    \item a monoid $(M, \ast, e)$ as the output domain
    \item two functions $f_A: \Sigma^* \to M$ and $f_B: \Sigma^* \to M$ that are computed by Alice and Bob respectively on their local inputs
\end{itemize}
The final output on inputs $x,y$ is $f_A(x)\ast f_B(y)$.
\end{definition}

We say that a function $f:\Sigma^* \to {\mathbb D}$ (where ${\mathbb D}$ is any output domain) is commutative if, for every word $u\in\Sigma^*$ and every permutation $\pi$ of the positions of $u$, we have $f(u)=f(\pi(u))$.

In Theorem~\ref{thm:commutative-signal-free}, we show the following: If, in a signal-free aggregation protocol over a commutative monoid, the neutral element $e$ of the monoid is in the image of both $f_A$ and $f_B$, then the protocol computes a commutative function $f:\Sigma^* \to M$.

\begin{theorem}
\label{thm:commutative-signal-free}
Let $(M, \ast, e)$ be a commutative monoid, and let $f_A, f_B: \Sigma^* \to M$ be two functions that define a signal-free aggregation protocol over $M$. If there exist words $w_A^{e}, w_B^{e} \in \Sigma^*$ such that $f_A(w_A^{e}) = e$ and $f_B(w_B^{e}) = e$, then the function $f: \Sigma^* \to M$ computed by the protocol is commutative. That is, for every word $u \in \Sigma^*$ and every permutation $\pi$ of the positions of $u$, we have $f(u) = f(\pi(u))$.
\end{theorem}

\begin{proof}
    First note that with the given conditions, $f_A(\epsilon)$ and $f_B(\epsilon)$ must be invertible elements in the monoid $M$. This is because first we know that there exist $w_A^{e}, w_B^{e} \in \Sigma^*$ such that $f_A(w_A^{e}) = e$ and $f_B(w_B^{e}) = e$. Now consider the words $w_A^{e}$ and $w_B^{e}$. We have:
    \[f(w_A^{e} w_B^{e}) = f_A(w_A^{e}) \ast f_B(w_B^{e}) = e \ast e = e.\]
    On the other hand, by split-invariance of protocols, we also have:
    \[f(w_A^{e} w_B^{e}) = f_A(\epsilon) \ast f_B(w_A^{e} w_B^{e}) = f_A(\epsilon) \ast f_B(w_A^{e} w_B^{e}).\]
    Combining these two equations, we get:
    \[e = f_A(\epsilon) \ast f_B(w_A^{e} w_B^{e}).\]
    This implies that $f_B(w_A^{e} w_B^{e})$ is the inverse of $f_A(\epsilon)$ in the monoid $M$. A similar argument shows that $f_A(w_A^{e} w_B^{e})$ is the inverse of $f_B(\epsilon)$.


    \begin{claim}
    For every word $u \in \Sigma^*$, we have:
    \[f_A(uv)= f_A(vu) \quad \text{and} \quad f_B(uv)= f_B(vu).\]
    \end{claim}  

    \begin{proof}[Proof of Claim]
    We proof the first equality; the second one follows by a symmetric argument. Let $u,v \in \Sigma^*$. First note that the following holds:
    \begin{equation}
        f(w) = f_A(w) \ast f_B(\epsilon) = f_A(\epsilon) \ast f_B(w) \label{eq:1}
    \end{equation}
    multiplying both sides by $f_B(\epsilon)^{-1}$ from the right and considering commutativity, we get:
    \begin{equation}
        f(w) f_B(\epsilon)^{-1} = f_A(w) = f_B(w) \ast f_A(\epsilon) \ast f_B(\epsilon)^{-1} \label{eq:2}
    \end{equation}
    and symmetrically we have:
    \begin{equation}
        f(w) f_A(\epsilon)^{-1} = f_B(w) = f_A(w) \ast f_B(\epsilon) \ast f_A(\epsilon)^{-1} \label{eq:3}
    \end{equation}

    \noindent 
    From Equation~\eqref{eq:2}, we have:

    \begin{equation}
    f_A(uv) = \underbrace{f(uv)}_{f_A(u) \ast f_B(v)} \ast f_B(\epsilon)^{-1}  = f_A(u) \ast f_B(v) \ast f_B(\epsilon)^{-1} \label{eq:4}
    \end{equation}
    \noindent
    Therefore the sequence of equalities below holds:
    \begin{align*}
    f_A(uv) & = f_A(u) \ast f_B(v) \ast f_B(\epsilon)^{-1} & \text{(from equation~\eqref{eq:4})} \\
    & = f_A(u) \ast f_A(v) \ast f_B(\epsilon) \ast f_A(\epsilon)^{-1} \ast f_B(\epsilon)^{-1} & \text{(from equation~\eqref{eq:3})} \\
    & = f_A(u) \ast f_A(v) \ast f_A(\epsilon)^{-1} & \text{(by cancellation)} \\
    & = f_B(u) \ast f_A(\epsilon) \ast f_B(\epsilon)^{-1} \ast f_A(v) \ast f_A(\epsilon)^{-1} & \text{(from equation~\eqref{eq:2})} \\
    & = f_B(u)  \ast f_B(\epsilon)^{-1} \ast f_A(v) & \text{(by cancellation)} \\
    & = f_A(v) \ast f_B(u)  \ast f_B(\epsilon)^{-1} & \text{(by commutativity)} \\
    & = f_A(vu) & \text{(from equation~\eqref{eq:4})}
    \end{align*}
    This completes the proof of the claim.
    \end{proof}

    \noindent
    For last intermediate step, we use the claim to show the following equalities:
    \begin{equation}
        f(uw) = f(wu) \quad \text{for every } u,w \in \Sigma^* \label{eq:cyclic_commutative}
    \end{equation}
    This is because:
    \begin{align*}
    f(uw) & = f_A(uw) \ast f_B(\epsilon) & \\
    & = f_A(wu) \ast f_B(\epsilon) & \text{(by the claim)} \\
    & = f(wu) &
    \end{align*}
    Also, for every $a,b \in \Sigma$ and every word $u \in \Sigma^*$, we have:
    \begin{equation}
        f(abu) = f(bau) \label{eq:adjacent_commutative}
    \end{equation}
    This is because:
    \begin{align*}
    f(abu) & = f_A(ab) \ast f_B(u) & \\
    & = f_A(ba) \ast f_B(u) & \text{(by the claim)} \\
    & = f(bau) &
    \end{align*}
    And symmetrically, for every $a,b \in \Sigma$ and every word $u \in \Sigma^*$, we have:
    \begin{equation}
        f(uab)= f(uba) \label{eq:adjacent_commutative_2}
    \end{equation}
    with similar reasoning.
    Now it is not had to see that using Equations~\eqref{eq:cyclic_commutative}, \eqref{eq:adjacent_commutative}, and \eqref{eq:adjacent_commutative_2}, we can transform any word $u$ into any permutation $\pi(u)$ of $u$ by a sequence of such transformations, proving that $f(u) = f(\pi(u))$. This completes the proof of the theorem.
\end{proof}



