
\subsection{Regular string-to-string functions}
\label{sec:regular-string-to-string-functions}

In this section, we define the class of regular string-to-string functions, and
we prove the implication $\impliedby$ in the conjecture. Historically, class of
regular string-to-string  functions was first defined in terms of deterministic
two-way automata with output~\cite[Note 4]{shepherdson1959reduction}. Although
numerous equivalent definitions appeared later on, we will use the original
definition.

 \begin{definition}[Two-way automaton]
   A \intro{deterministic two-way automaton with output} is given by the following ingredients:
    \begin{enumerate}
        \item a finite input alphabet $\Sigma$;
        \item a finite output alphabet $\Gamma$;
        \item a finite set of states $Q$, with an initial state $q_0 \in Q$;
        \item a transition function  
        \begin{align*}
        \delta : 
        \myunderbrace{Q}{old \\ state} \times 
        \myunderbrace{(\Sigma + \{\vdash, \dashv\})}{input letter\\ under  the head} \to  \set{\text{halt}} + (
        \myunderbrace{Q}{new \\ state}
         \times 
         \myunderbrace{\{-1,0,1\}}{head \\ movement} \times 
         \myunderbrace{\Gamma^*}{added \\ output}) .
        \end{align*}
    \end{enumerate}
 \end{definition}

The automaton works as follows. The input string $w$ is placed on a tape,
with the left end marked by $\vdash$ and the right end marked by $\dashv$.
The automaton starts in state $q_0$, with its head on the left end of the
tape, which contains the marker $\vdash$. In each step, the automaton looks
at its current state and the letter under its head, and based on this
information, it uses the transition function to decide if it halts, or it
continues its computation. In case it continues, it chooses a  new state,
the direction in which it moves its head, and a string over the output
alphabet $\Gamma$, which is appended to the output tape. We assume that the
automaton is always halting, which means that for every input string, the
computation eventually halts. In particular, the computation must be
well-defined, which means that the head never falls off the input by moving
outside the endmarkers.   The semantics of such an automaton is of type
$\Sigma^* \to \Gamma^*$. (For automata which are not necessarily halting,
the function would be partial, since it would be undefined for inputs where
the automaton does not halt.)

    \begin{myexample}[Reverse]
        For each input alphabet $\Sigma$, the reverse function of type $\Sigma^* \to \Sigma^*$ is computed by a  two-way automaton, which first moves its head to the end of the string, and then starts copying it to the output while moving in the left direction.
    \end{myexample}

    The class of functions computed by two-way automata has a remarkable number
    of equivalent descriptions,  originating in different fields, including:
    monadic second-order transductions~\cite[Section
    4]{engelfrietMSODefinableString2001}, streaming string
    transducers~\cite[Section 3]{alurExpressivenessStreamingString2010},
    certain kinds of regular expressions~\cite[Section 2]{alur2014regular}, a
    calculus of functions based on  combinators~\cite[Theorem
    6.1]{bojanczykRegularFirstOrderList2018}, a characterisation based on
    natural transformations~\cite[Theorem 3.2]{bojanczykTitoRegular23}. For
    this reason, some authors (starting with Engelfriet and Hoogeboom), use the
    name \emph{regular} for this class of function, with the intended meaning
    being that these functions are the functional analogue of regular
    languages. Although this thesis can be questioned,
    see~\cite{polyregular-survey}, for the purposes of this paper we adopt the
    terminology of Engelfriet and
    Hoogeboom~\cite[p.~217]{engelfrietMSODefinableString2001}, as expressed in
    the following definition.


    \begin{definition}[Regular string-to-string function]
        \label{def:regular-string-to-string}
        A string-to-string function is called \intro(function){regular}
        if it is computed by a \kl{deterministic two-way automaton with output}.
    \end{definition}
    
    
    One good  property of the regular string-to-string functions is that they
    are closed under composition~\cite[Theorem
    2]{chytilSerialComposition2Way1977}. In particular,
    Conjecture~\ref{conj:protocol-regular-string-to-string} would imply that
    the same is true for functions computed by protocols. Without proving the
    conjecture, we do not see any direct way of proving composition for
    protocols. The  regular string-to-string functions have other good
    properties, such as decidable equivalence~\cite[Theorem
    1]{gurariEquivalenceProblemDeterministic1982}, but we do not discuss these
    in more detail, since they seem to have little direct bearing on protocols.


    The following lemma shows one of the implications in the conjecture.

\begin{lemma}\label{lem:from-regular-to-protocol}
    If a string-to-string function is \kl(function){regular}, then it is computed by a \kl{protocol}.
\end{lemma}
\begin{proof}
    The two parties can simulate a \kl{two-way automaton} with output. The execution
    of the \kl{protocol} describes the \intro{crossing sequence} of the automaton, i.e.~how
    it crosses the boundary between the two \kl{local string}s of Alice and Bob.
    Here is a picture: \mypic{1} More formally, the \kl{crossing sequence} is
    defined as follows, given  a split of the input string into two parts $w_1
    w_2$. We run the automaton until the first configuration which is in the
    word $w_2$. Then we run it until the first configuration which is in the
    word $w_1$. We continue this way, with odd-numbered steps describing runs
    inside $w_1$ that end in  configurations from $w_2$, and even-numbered
    steps describing runs inside $w_2$ that end in a configuration from $w_1$.
    The last step is exceptional, since it ends with an accepting
    configuration. The number of steps in a \kl{crossing sequence} is bounded  the
    number of states, since otherwise the automaton would enter an infinite
    loop. This bound is the \kl{number of rounds} in the \kl{protocol}. In each round,
    the state corresponding to this round is sent as a signal, and the output
    value in the message is the  part of the output string that is produced in
    this  step. At the end of the protocol, the pieces of the output string are
    concatenated. 
\end{proof}

In view of the above lemma, the content of the conjecture is the opposite
implication, namely that every protocol computes are regular function.  The
rest of Section~\ref{sec:string-outputs} is devoted to  evidence for the
opposite implication.


