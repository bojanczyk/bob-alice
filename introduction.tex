% LTeX: language=en
\section{Introduction}
\label{sec:introduction}

\AP
This paper is motivated by a desire to understand the notion of  regularity in formal language theory. We take the functional perspective, in which we consider functions 
\begin{align*}
f : \Sigma^* \to \domain
\end{align*}
that input strings, and output values from some domain $\domain$. If the output
domain is the Booleans, then such functions are languages, and there is no
question about which languages should be considered \intro[regular language]{regular}. There are tens --
if not hundreds -- of equivalent definitions, including regular expressions,
finite automata in numerous forms, monoids, monadic second-order logic, and
variants of $\lambda$-calculus. But what about other outputs? Let us review
three examples where the nature of regularity is a topic of genuine
discussion.

\begin{enumerate}
    \item \textbf{String outputs.}
Consider string-to-string functions 
\begin{align*}
f : \Sigma^* \to \Gamma^*.
\end{align*}
Similarly to languages, the literature on automata theory offers countless  models. This time, however, not all of them are equivalent, but there is at least some semblance of order. Let us mention three classes of functions  of particular interest:  the \emph{rational}, \emph{regular}, and \emph{polyregular} functions. These classes are described in~\cref{fig:transducer-classes} in Section~\ref{sec:string-outputs} together with the appropriate references, with each one having at least five different characterisations, using models of varied origins, including logic, algebra and programming language theory. Which of these classes, if any, should be considered ``the'' regular string-to-string functions? We could simply go with the middle one, because  the word ``regular'' is traditionally used for it, but a more principled approach would be preferable.

\item \textbf{Number outputs.}
Consider string-to-number functions, say functions 
\begin{align*}
f : \Sigma^* \to \Rat
\end{align*}
that output rational numbers (more generally, the outputs could be in some field). Here, the literature offers two natural candidates, namely \emph{weighted automata}~\cite{schutzenberger1961definition}, and \emph{polynomial automata}~\cite[Section IV]{DBLP:conf/lics/BenediktDSW17}. In both cases, there is an automaton that reads the input string in one pass, and stores in its state a vector $\Rat^d$ of some fixed dimension. In weighted automata, this vector is updated using linear maps, while polynomial automata can use polynomial maps. These models are not equivalent -- polynomial automata are strictly more powerful -- but both have a good mathematical theory, one based on linear algebra, and the other based on algebraic geometry. Again, we might be tempted to ask: which  is the right one?

\item \textbf{Infinite input alphabets.}
Our final example is of a different kind than the previous ones. We return to functions with Boolean outputs
\begin{align*}
f : \Sigma^* \to \set{\text{true, false}},
\end{align*}
i.e.~languages, but this time the input alphabet is no longer required to be finite. The infinity needs to be somehow tamed, and the standard approach to do this is to use an infinite alphabet where letters can only be compared for equality~\cite{kaminskiFiniteMemoryAutomata1994}. This allows for languages such as ``all letters are different'' or ``the first letter is equal to the last one'', but not for languages such as ``the letters are in increasing order'', since the letters are not equipped with a linear order, or any other kind of structure.
The literature is rife with automata models for such languages, with seventeen examples listed in \cref{fig:automata-infinite-alphabets}, all describing pairwise non-equivalent models. 
 Again, we might be tempted to ask: which  is  the right one?
\end{enumerate}

This type of question can be asked in other settings, with   outputs such as  trees,  graphs or elements of some abstract semiring. One could also vary the inputs, and consider regularity for, say, graph-to-graph functions, but we refrain from considering general outputs in this paper, and we stay with string inputs. This paper attempts to provide a unified theory of regularity for such functions.   We are guided by  the following principle, which we believe to be essential for regularity:
\begin{description}
    \item[Constant information flow.]   If the input is split into parts, then only a constant amount of information  flows between them, as far as the output of the function is concerned.
\end{description}
This principle is only a vague guideline, since it does not identify what
``information flow'' means, or how to quantify its amount. For Boolean outputs,
i.e.~languages, constant information flow has a standard interpretation, which is the
Myhill-Nerode Theorem, and it is known to
correspond exactly to the regular languages. However, in the case of more
complicated outputs, things are less clear.  For example, if the outputs of the
function are rational numbers, then it should be legitimate for the information
flow to contain some rational numbers. How should this be formalised?

\AP
We choose to use a formalisation that is based on communication complexity~\cite{YAO79,KUSH97}. In our model, the function is computed by two cooperating parties, called Alice and Bob. 
There are \textbf{no uniformity assumptions} and the two parties
have unrestricted computational power; the goal is to measure information 
% \omc{information flow instead of information ?}
% it is a bit of a wordplay on the name of the journal Information and Computation :)
and
not computation.  The input string is split into two parts $w = w_1 w_2$, and
Alice has access to $w_1$ while Bob has access to $w_2$. The two parties  exchange  a
\textbf{constant number of messages} in order to compute the function, where the constant  depends only on the
protocol and not on the input string. The  output of the computation must
be \textbf{split invariant}, which means that the output depends only on the
input string $w$, and not on the split $w = w_1 w_2$. In the communication,
there are two kinds of messages:  either bits in $\set{\text{true, false}}$  or
elements of the output domain (as far as we can tell, the messages from the domain are the novelty of our approach).
% \omc{This may be my subjective view (as I mentioned before), but I don’t think it’s a good idea to describe the messages as bits in our paper. I understand that you did this because it’s the convention in the communication complexity community. However, I would prefer saying that either the message comes from a finite set, or … The reason is that, for detail-oriented readers within the communication complexity community, in this setting the parties should either alternate turns when sending messages to each other, or there should be a "Next" function specifying the next communicator based on communication history.
% Using a finite set instead of bits allows parties to send information that might require several rounds rather than just one. I suppose you wrote it this way to appeal to readers already familiar with communication complexity and to make the paper more attractive to them. If that’s the reason, then it makes sense to keep it as is. Otherwise, I think it would be better to take a consistent approach and use a finite set for the visible part of the messages.}. 
% Thanks Omid! I understand your point. However, I did indeed want to start with the more standard terminology in the introduction; and later start using the terminology for our paper.
For example, if the outputs are rational
numbers, then the messages can contain rational numbers. However, there is a
restriction on the access to messages from the output domain, which is called
the \emph{\textbf{\intro{black box restriction}}}. This restriction (which will be formally
defined later in the paper) is intended to prevent tricks such as Alice sending
her input string to Bob encoded as a rational number. Intuitively speaking,
the  black box restriction says that the parties cannot read the messages from
the output domain, and instead they can only operate on them using predefined
operations. For example, in the case of numbers, the operations are addition
and multiplication.

The model, which we call \emph{protocols}, can be applied to any output domain,
and we study several examples in this paper. In the case of Boolean outputs, the model and its connection to finite automata have already been studied before~\cite[Theorem 5]{hauser1989}, however the results on other output domains are new up to our best knowledge.   As we discover, despite its
non-uniformity, the model  can only define well-behaved functions. In
particular, in all cases that we have studied  these functions are: (1)  always
computable, even in linear time; and (2) the output size is always at most
linear (with the size of a rational number measured by the number of bits
needed to represent it).  This seems to indicate that the split invariance,
together with a  constant number of messages under the black box restriction,
has unexpected computational consequences. In particular, in all cases that we
have studied, protocols coincide -- or are conjectured by us to coincide --
with existing automata models. Since automata are conceptually very different 
than protocols, we believe that those equivalences, summarized in the table below,
justify the protocol-based approach to regularity.

\begin{center}
    \begin{tabular}{ll}
    \textbf{Output} & \textbf{Automata Model} \\
    \hline
    \kl[Boolean domain]{Booleans} & Finite automata (\cref{thm:boolean-domain}) \\
    \kl[String domain]{Field}   & Weighted automata (\cref{thm:field-domain}) \\
    \kl[String domain]{Strings} & Two-way automata with output (\cref{conj:protocol-regular-string-to-string}) \\
    Boolean, but infinite input alphabet & Unambiguous automata (\cref{conj:protocols-unambiguous}) 
\end{tabular}
\end{center}

In the remainder of this introduction, we give a more detailed review of the four rows
in the table, including substantial evidence for the conjectured equivalences.
% One piece of evidence that is worth mentioning here is that
% we were able to prove the equivalence for string outputs in the special case
% of \emph{unary} output alphabets (\cref{thm:unary-string-to-string}).

\subsection{Protocols for Boolean outputs}
\label{sec:intro-boolean}

We begin by studying the protocol model for  functions
\begin{align*}
f : \Sigma^* \to \set{\text{true, false}},
\end{align*}
i.e.~languages. This case is not new, and it has already been studied in~\cite{hauser1989}. For Boolean outputs, the two parties only exchange bits, 
% \omc{I still think it’s better to say that the messages come from a finite set instead of bits.} 
and they need to decide if the input string is in the language or not.
Here is an example.

\begin{myexample}[Parity]
    \label{ex:three-letters}
Suppose that the language is ``the string has even length''. In a protocol for this language, Alice sends the parity for her part of the input (one bit), and Bob uses this bit to return the final answer.  
\end{myexample}

As mentioned before, the parties have unbounded computational power, which means that  their messages
can contain answers to potentially undecidable questions about their parts of the input.
Despite this, the protocols compute exactly the regular languages.
This was first shown in~\cite[Theorem 5]{hauser1989}, but we restate it here for completeness, and provide a self-contained proof later in the paper.

\begin{restatable}{theorem}{booleandomain}
 \label{thm:boolean-domain} A language $L \subseteq \Sigma^*$ is computed by a \kl[boolean protocol]{protocol} if and only if it is 
 \kl[regular language]{regular}.
\end{restatable}
One implication is immediate: every regular language can be computed by a protocol.  Alice can send to Bob the state of a finite automaton that recognises the language. The other implication is proved in two steps, see Section~\ref{sec:boolean-domain} for more details. In the first step, the protocol is reduced to a one-round non-interactive version, where each party independently sends a message with a constant number of bits, and the decision is then made based on these two messages. In the second step,  the Myhill-Nerode Theorem is used to show that the language must necessarily be regular. 

Theorem~\ref{thm:boolean-domain} is  simple  technically, and its main value for us lies in its role as an inspiration for other results, which use  other output domains  such as  fields or strings. 


% It is worth underlining that, unlike in communication complexity, we are not interested in the exact number of exchanged bits. For example, in the round reduction that is described in the previous paragraph, the number of exchanged bits increases exponentially. One could investigate the constant in more detail, e.g.~how it depends on some parameters of the language, such as the number of states in an automaton that recognises it. We do not pursue this direction in this paper.

Before moving to the other output domains, let us comment on other related work that connects communication complexity with automata in the case of Boolean outputs.  Much of this work is related to \emph{state complexity}, where one studies  the number of states needed for a given language in a given automaton model, and how this number is affected by operations on languages or changes in the model. See  Wikipedia~\cite{stateComplexityWiki} for a comprehensive summary with numerous references, or the recent paper~\cite{goosKiefer2022} which shows how to transfer lower bounds from communication complexity to state complexity of unambiguous automata. 
% \omc{Remove the Wikipedia source and keep only the Goos and Kiefer (2022) reference. I think the Wikipedia source is redundant.}
% MB: I think that the Wikipedia source contains a lot useful references, more so than the Good and Kiefer paper. I would keep it.
 The work on state complexity is mainly about the exact number of states, which is of secondary concern to us. For our purposes, a protocol that exchanges $k$ bits is no different from a protocol that exchanges $2^k$ bits. We only care that this bound should be finite and independent of the input.



\subsection{Field outputs}
\label{sec:intro-field}



After the Booleans, we turn to functions with outputs in a field. This is the first original contribution of this paper. For the sake of concreteness, let us  consider functions with outputs in the  field of rationals
\begin{align*}
f : \Sigma^* \to (\mathbb Q, +, \times).
\end{align*}
We adapt the  protocol model to  compute such functions. Similarly to the Boolean case, the parties exchange messages. However, this time there are two kinds of messages: bits (as in the case of  Boolean outputs), and  elements of the field.  The elements of the field can be added and multiplied.  Division is not allowed, and its role is discussed in Example~\ref{ex:division}. Using bit messages, we can still recognise all regular languages (more formally their characteristic functions).
However, messages from the field allow computing new functions.

\begin{myexample}[Length and exponential length]\label{ex:length}
    Consider the following two functions
\begin{align*}
\myunderbrace{w \mapsto |w|}{length} \qquad \text{and} \qquad \myunderbrace{w \mapsto 2^{|w|}}{exponential length}.
\end{align*}
To compute the length of the input string, Alice  sends the length of her part, and Bob adds this to his length, thus yielding the desired output. For the exponential length, we use a similar protocol, except that multiplication is used instead of addition. 
\end{myexample}


In the presence of an infinite message space, one needs to be careful about the design of the protocol. For example, Alice could try to send her part of the input string in a single message by encoding it as a rational. This would trivialise the model, enabling every function to be computed. To prevent such tricks, we use the \emph{black box restriction} which was discussed before\footnote{The black box postulate is related to  polymorphic parametricity from the theory of programming languages~\cite[Section 7]{reynolds1983types}, or to the recent algebraic group model in cryptography~\cite[Section 1.2]{fuchsbauer2018algebraic}. An important difference with the algebraic group model is that our model does not allow for equality tests, see Example~\ref{ex:equality-tests} for a discussion.}: the messages which use the output domain (in this case, rational numbers) cannot be read directly, but can only be acted on by the operations in the output domain (in this case addition and multiplication).
 If the output domain is finite, e.g.~it is a finite field, then the black box restriction is irrelevant (which is why it was not mentioned when talking about Boolean outputs). This is because one can use bits to sent elements of a finite output domain, and the bits are a preferrable communication channel, since they can be read directly and are not subject to the black box restriction. 

\paragraph*{Definition of the protocol model.} Since there might be some ambiguity as to what exactly is allowed in the protocol, we give a more formal  definition. There is a finite input alphabet $\Sigma$, and a constant number of rounds $k \in \set{1,2,\ldots}$.   Alice and Bob send messages in alternation, with Alice sending the first message\footnote{One could consider other patterns of communication. In fact, in Section~\ref{sec:beyond-boolean-outputs} we use a more symmetric variant where both parties move in parallel in each round. These variants  do not change the expressive power of the model, only the  number of rounds.}. The messages are from 
\begin{align*}
\myunderbrace{\set{\text{true, false}} + \Rat}{disjoint union of bits and rational numbers}.
\end{align*}
When choosing their message in the $i$-th round, the corresponding  party (Alice in odd rounds, Bob in even rounds) has access to their part of the input string, and the  bits from previous messages. The numbers  are rationals, and cannot influence the decision, as per the black box restriction.  The information available  in the $i$-th round is given by  the set 
\begin{align}\label{eq:strategy-input}
\myunderbrace{\Sigma^*}{part of the  input \\ string that is \\ known to the party}
\qquad \times \qquad 
\myunderbrace{\set{\text{true, false, unknown}}^{i-1}}{messages received in  previous rounds, \\ with  numbers from $\Rat$ replaced by ``unknown''}.
\end{align}
Based on this information, the corresponding party chooses a new message to  send, which is either a bit, or a number. The number can be produced in two ways: either  a  fresh number  is produced based on the available information, or otherwise two previously received numbers are combined using addition or multiplication.  Therefore, the possibilities for the message sent in the $i$-th round are described by the set 
\begin{align}
    \label{eq:strategy-output}
\myunderbrace{\set{\text{true, false}}}{bits}
\ + \ 
\myunderbrace{\Rat}{fresh \\ number}
\  + \ 
\myunderbrace{\setbuild{(op,x,y)}{$op \in \set{+,\times}$ and $x,y \in \set{1,\ldots,i-1}$}}{addition or multiplication of previously received numbers}.
\end{align}
If addition or multiplication is used, then the party sending the message is responsible for the operation to be well-defined, i.e.~the messages sent in rounds $x$ and $y$ must have been numbers.
Summing up, the strategy in round $i$ is a function which inputs an element of the set from \eqref{eq:strategy-input}, and outputs an element of the set from \eqref{eq:strategy-output}. This function need not be computable. The protocol is then described by $k$ such strategies, one for each round $i \in \set{1,\ldots,k}$. We assume that the last message, sent in the $k$-th round, is a number and not a bit -- this number is defined to be the output of the protocol. 
Finally, the protocol must be \kl{split invariant}, i.e.~for every input string $w$, the same output must be produced regardless of the factorization $w = w_1 w_2$ into strings owned by Bob and Alice. This completes the definition of the protocol model, in the case of field outputs.


\paragraph*{Equivalence with weighted automata.} Our main result for field outputs is~\cref{thm:field-domain} below, which says that protocols are equivalent to weighted automata. The precise definition of weighted automata will be given later in Section~\ref{sec:field-domain}, but the rough idea is that a weighted automaton maintains a vector  $\domain^d$ of field elements, with each input letter updating the vector via some fixed linear map.  


\begin{restatable}{theorem}{fielddomain}
    \label{thm:field-domain}
     Assume that the domain $\domain$ is a field. Then a function 
    \begin{align*}
    f : \Sigma^* \to \domain
    \end{align*}  is computed by a \kl{protocol} if and only if it is  computed by a \kl{weighted automaton} over the same field.
\end{restatable}



  This result might even seem surprising. Our protocol is designed to use polynomial operations on the output domain, and therefore one could expect the relevant automaton model to be also based on polynomials, such as the  polynomial automata of~\cite{DBLP:conf/lics/BenediktDSW17}, which are the extension of weighted automata that allow polynomial maps instead of linear ones. As it turns out, the split invariance in the protocols  enforces linearity, and thus it excludes the general polynomials operations that are used in polynomial automata. The linearity phenomenon is true for outputs in a field -- because weighted automata are based on linear maps -- and it will also be true for other output domains, such as strings, see \cref{thm:evidence-for-the-conjecture}. We do not have a fully general understanding of this phenomenon.

  The proof of \cref{thm:field-domain} is given in Section~\ref{sec:proof-of-thm-field-domain}, but here we present a rough outline.  The proof is similar to the one used for the case of Boolean outputs, and has  two steps:

\begin{enumerate}
  \item We first show in Section~\ref{sec:reduction-to-scalar-product-protocols} that any protocol with outputs in a field can be reduced to a special  form, which we call a \emph{\kl{scalar product protocol}}. In this protocol, Alice and Bob apply in parallel two functions 
\begin{align*}
\sigma_A, \sigma_B : \Sigma^* \to \Rat^d
\end{align*}
to their parts of the input string, where $d$ is some fixed finite dimension. Then, the output is obtained by combining these two  $d$-dimensional vectors using scalar product. A scalar product protocol can be simulated by the general version of the protocol, but it is subject to certain restrictions: (a) there is no interaction; and (b) bits are not used, only  field elements. Since, as we prove, every product can be reduced to this scalar form, it follows that interaction and bit messages are not needed in the protocol. In fact, the interaction can be removed for all output domains, but the removal of bits is specific to fields. 
\item After reducing to the scalar product protocols, the next step (see Section~\ref{sec:from-scalar-product-protocol-to-weighted-automaton}) is to apply a version of the Myhill-Nerode Theorem for weighted automata. This is called the  Fliess Theorem~\cite{fliess1974}, and it says that recognisability by a weighted automaton is equivalent to having finite rank for a certain matrix, which is called the Hankel matrix. Roughly speaking, the rows in the Hankel matrix, in the context of our protocols, describe strategies of Alice, and the columns describe strategies of Bob. Therefore, it is not hard to show that in a scalar product protocol that uses vectors of dimension $d$,  the Hankel matrix has rank at most $d$. This, together with the Fliess Theorem, shows that protocols are equivalent to weighted automata, completing the proof of \cref{thm:field-domain}.
\end{enumerate}

 




\begin{myexample}[Division]\label{ex:division} What if we added division to the operations?  Consider the function  $w \mapsto 1/(|w|+1)$. This function can easily be computed using a protocol with division. We now argue that it cannot be computed using addition and multiplication only, thus proving that division gives extra power. Since the function depends only on the length of the input, it can be seen as having type $\Nat \to \Rat$. In such a type, weighted automata are the same as linear recurrence sequences. The inverse function $1/(n+1)$ is not a  linear recurrence sequence, which can be shown using the exponential polynomial form~\cite[Theorem 2.1]{BerstelReutenauer08}. Summing up, the choice of operations is important; we use a field, but we only allow the ring operations. We do not know what happens if division is allowed.
\end{myexample}

\paragraph*{Related work.} \cref{thm:field-domain} can be seen as a machine independent characterisation of  weighted automata. This would not be the first such characterisation, e.g.~the Fliess Theorem itself can be seen as a machine independent characterisation. Other research related to the Fliess Theorem is the categorical approach to  minimisation of weighted automata from~\cite{colcombetPetrisan2017}. We think that the value of our approach is that it places weighted automata in a broader context, which is defined purely in terms of communication, and in a way that is applicable to  other output domains, such as strings that will be considered next. As far as we know, the only  work  which takes such a broad view is the cost register automata of~\cite[Section C]{alurDantoniDeshmukhYuan2013}, which are an automaton model that describes functions with outputs in an arbitrary output domain, similarly to our setting. However, unlike our model, cost register automata are defined in terms of a  finite state machine model, and as such they lack the abstract machine independent flavour of our approach.

\subsection{String outputs}
\label{sec:intro-strings}

Our third group of results concerns string-to-string functions
\begin{align*}
f : \Sigma^* \to \Gamma^*.
\end{align*}
We  use the same kind of protocol as in the previous section, except that instead of numbers, the black box messages  contain strings from $\Gamma^*$, and instead of addition and multiplication, we have string concatenation.  Here are some examples.

\begin{myexample}[Reversal and duplication]\label{ex:reverse-duplicate}
    Using the protocol, we can compute string reversal: Alice sends to Bob the reverse of her part of the input, and  Bob concatenates this with  his part of the reverse. Another string-to-string function that can be easily computed by a protocol is string duplication $w \mapsto ww$. 
\end{myexample}

The string-to-string case is of particular interest because, as we have mentioned earlier in the introduction, there is no consensus as to  which string-to-string functions should be considered ``regular''. There are numerous automata models to choose from, some of which are summarized in \cref{fig:transducer-classes}, which contains twenty models, grouped by equivalence into three classes. We can exclude the weakest class (the rational functions), since it is too weak: it  cannot compute the reverse or duplicate functions from Example~\ref{ex:reverse-duplicate}. We can also exclude the strongest class (the polyregular functions), since it is too strong: polyregular functions can have superlinear output size, and as we will see in a moment, protocols can only have linear output size. By a process of elimination, we are left with the final  class from \cref{fig:transducer-classes}, which is traditionally called the ``regular functions''. One of the definitions of the class is in terms of   deterministic two-way automata with output~\cite{shepherdson1959reduction}; this model  is formally defined in Section~\ref{sec:string-outputs}. We conjecture  that this class     is the correct answer (thus validating the traditional name): 

\begin{conjecture}\label{conj:protocol-regular-string-to-string}
    A string-to-string function is computed by a protocol iff it is computed by a deterministic two-way automaton with output.
\end{conjecture}

In Section~\ref{sec:string-outputs} we discuss this conjecture in detail, and provide evidence in its favour, including a proof of the  implication 
\begin{align*}
\text{protocol} \quad \impliedby \quad \text{two-way automaton},
\end{align*} 
This implication is rather easy, since a two-way automaton can be neatly simulated by the repeated interactions of the protocol. The content of the conjecture, and the subject of the more technical results, is the $\implies$ implication. Most of Section~\ref{sec:string-outputs} is devoted to evidence for this implication. 
Our first argument  is the following result, which shows that functions computed  by protocols have many properties which are known to hold for deterministic two-way automata with output.


\begin{restatable}{theorem}{evidencefortheconjecture}
    \label{thm:evidence-for-the-conjecture}
    If a string-to-string function  is  computed by a \kl{protocol}, then:
    \begin{enumerate}
        \item \label{it:linear-size-outputs} outputs have at most linear size;
        \item \label{it:linear-time-computable} outputs can be   computed in linear time (ignoring logarithmic factors);
        \item \label{it:regular-preimages} preimages of regular languages are regular.
    \end{enumerate}
\end{restatable}

One can invent functions which satisfy the three conditions in the above
theorem, but which are not computed by deterministic two-way automata with output, see
Example~\ref{ex:not-regular-but-continuous-over-finite-fields}. However, all
known examples of such functions  are artificial, and none can be computed by
protocols (or any known transducer models).  The proof of
\cref{thm:evidence-for-the-conjecture}, which is given in
Section~\ref{sec:string-outputs}, uses a linear representation of strings as
matrices, and then applies \cref{thm:field-domain} about protocols with field
outputs. In fact, this technique suggests an alternative approach to regularity,
which connects string-to-string functions with the better understood case of
string-to-field functions. This approach is discussed in
Section~\ref{sec:continuity}.

Our second argument in favour of the \cref{conj:regular-continuous} is that we
can prove it in the special case when the output alphabet is unary, i.e.~it has
only one letter. This is the content of
Section~\ref{sec:unary-output-alphabet}. When the output alphabet is unary, the
output strings are commutative, i.e.~the order of letters is irrelevant; this commutativity is essential to our proof of the conjecture in the unary output case.  The proof is based on well-quasi orders, plus some results on weighted automata.



\paragraph*{Related work.} One of the consequences of the Myhill-Nerode theorem
for string-to-Boolean functions, or the Fliess Theorem for string-to-number
functions, is the existence of  canonical devices. There have been several
attempts to generalise this to string-to-string functions, with a special
emphasis the canonical devices. Before recalling this work, we observe that our
approach seems to go in a  different direction. Although we think of
Conjecture~\ref{conj:protocol-regular-string-to-string} as being a machine
independent characterisation, it does not necessarily  yield canonical devices.
In particular, our proof of the conjecture for unary alphabets does not yield a
canonical device.

Here is a summary of results on canonical devices for string-to-string
transducers: they have been proposed for subsequential functions~\cite[Théorème
1.1]{choffrut1977}, rational functions in~\cite[Theorem
1]{reutenauerSchutzenberger1991},  and for rational functions on infinite
words~\cite[Section 4]{canonicalRational2018}. A certain drawback of this line
of work is that: (a) the canonical devices are relative to a given automaton
model, which does not help in choosing one model over another; and (b) the
``canonical'' devices are not truly unique, since they depend on extra
parameters, such as the output delay for subsequential functions or the
lookahead for rational ones. Let us now move to the larger class of regular
functions, which is the subject of our conjecture. Here,  canonical model are
unknown, and the only known way to recover them uses non-standard semantics,
called origin semantics~\cite[Theorem
1]{bojanczykTransducersOriginInformation2014}. Another result of this kind,
which is a machine independent characterisation of the regular functions that
does not yield canonical devices, see \cite[Theorem
3.2]{bojanczykTitoRegular23}, is also implicitly based on origin semantics.
Finally, for the polyregular functions, the situation is of course even harder,
and the only known results concern a unary output alphabet~\cite[Section
IV]{Zpolyreg23}.


\subsection{Infinite input alphabets}
\label{sec:intro-infinite}
Our final group of results is about languages over infinite input alphabets. This is a departure from the previous setting, where  the input alphabet was always finite. Following the standard approach in automata theory, we assume that letters can only be compared for equality. Formally, we only want to consider languages that are invariant under permutations of the
alphabet, i.e.
\begin{align*}
w \in L 
\quad \iff \quad
\pi(w) \in L \qquad \text{for every permutation $\pi$ of the alphabet}.
\end{align*}
An example of such a language is ``all letters are different'', but not ``the letters are in the increasing order''.
 As mentioned earlier in the introduction, there is a rich literature on automata for such languages, see the surveys~\cite{neven2003power,segoufin2006automata,bojanczykOrbitFiniteSetsTheir2017} or the lecture notes~\cite{bojanczyk_slightly}.  The  relevant automata models typically use registers to store some letters from the input, so that they can be compared to later letters. Essentially any automaton model for finite alphabets can be lifted this way to infinite alphabets~\cite[Figure 1]{neven2003power}, and there is even a systematic way to do this, which is based on the theory of orbit-finite sets~\cite[Chapter 2]{bojanczyk_slightly}. Unfortunately, after this lifting, previously equivalent models become non-equivalent.  This sad situation is illustrated in~\cref{fig:automata-infinite-alphabets}, which describes seventeen non-equivalent automata models for infinite alphabets; all of these models collapse to the regular languages when considered for finite alphabets. Equally sadly, there are almost no results in the literature on infinite alphabets that prove non-trivial equivalences of models. The only known cases of this kind are about the  weakest of the available models, namely orbit-finite monoids~\cite{bojanczykNominalMonoids2013}, which are known to be equivalent in expressive power to a certain variant of \mso~\cite[Theorems 4.2 and 5.1]{DBLP:journals/corr/ColcombetLP14}, and also to single-use register automata~\cite[Theorem 6]{bojanczykstefanski2020}.
This situation desperately calls for some unifying principles. 

Since protocols have successfully identified important models in the previous
cases, we try to see  what happens in the case of an infinite input alphabet.
When extending protocols to infinite input alphabets, we adapt them as follows:
(1) messages can contain input letters; (2)  input letters can only be compared for
equality. Condition (2) is formalised by saying that the execution of the
protocol is invariant under permutations of the input alphabet, similarly to
the languages that we consider. The protocols  work their magic once again, and
they point to (as we conjecture)  one of the models in the literature. Before
revealing this model, let us briefly compare protocols to the two most prominent models 
for infinite alphabets.

\begin{myexample}[Deterministic too weak]\label{ex:reg-det-too-weak} We begin by considering a popular deterministic automaton model for infinite alphabets, namely i.e. \emph{deterministic register automata} \cite[Definition~3]{kaminskiFiniteMemoryAutomata1994}. This model is defined formally in Section~\ref{sec:infinite-alphabets}, but roughly speaking it is nondeterministic a finite automaton that is additionally equipped  with a fixed number of registers, which can be used to store input letters and compare them for equality with later input letters.  For example, the automaton can store the first input letter in a register, and then compare it with all later letters, thus recognising the language ``the first letter appears elsewhere in the word''. 

    A protocol can simulate any deterministic register automaton, using the same idea as for finite alphabets,
    i.e. Alice sends the intermediate state, including the register values, to Bob, who 
    continues the run on his side. To see that the inclusion is strict, consider the language
    ``the last letter appears elsewhere in the word'', which is the reverse of the language described in the previous paragraph. It is computed by a protocol, 
    in which Bob checks the condition on his side, and sends the last letter to Alice, so that she can verify
    that it does not appear on her side. On the other hand, it is a well-know fact that this language
    is not recognised by a deterministic register automata, as it proves that deterministic register automata 
    are not closed under reverse \cite[Examples~4~and~8]{kaminskiFiniteMemoryAutomata1994}. 
\end{myexample}

% \begin{myexample}[Deterministic too weak]\label{ex:reg-det-too-weak}

%     Deterministic register automata \cite[Definition~3]{kaminskiFiniteMemoryAutomata1994} is 
%     an automaton model equipped with a finite state, and a fixed number of register used for
%     storing and comparing input letters. An example of a language that can be recognised by this 
%     model is ``the fist letter does not appear elsewhere in the string''. The automaton 
%     can save the first letter in its register compare it with every other input letter, remembering in 
%     its finite state if it has found a reappearance. However, the reverse of this language,
%     i.e. ``the last letter does not appear elsewhere in the string'' is no longer recognized 
%     by deterministic register automata: In order to compare the last letter with all
%     other letters that appear in the word, the automaton would have to store all those letters in its memory, which cannot be done 
%     using a fixed number of registers.

%     A protocol can simulate any deterministic register automaton, using the same idea as for finite alphabets: Alice computes the intermediate state and register values and sends them to Bob, who continues the run of the automaton on his side. In particular, in order to compute the language
%     ``the fist letter does not appear elsewhere in the string'' Alice can check the condition on her side, and then send the first letter to Bob,
%     so that he can check the condition on his side. However, the inclusion is strict.
%     In particular, as a symmetric model they can compute the reverse of the language above, i.e.
%     ``the last letter does not appear elsewhere in the string'' (in the protocol Alice takes the role of Bob and vice versa).
% \end{myexample}
    
% In the previous example, we excluded deterministic register automata as being too weak. We now exclude nondeterministic register automata as being too strong. 

\begin{myexample}[Nondeterministic too strong]
    \label{ex:reg-ndet-too-strong} Consider the nondeterministic variant of the automata from the previous paragraph~\cite[Definition~1]{kaminskiFiniteMemoryAutomata1994}. This model is already too strong for the protocols, as attested by the language
    ``some letter appears twice'', which can be computed by an automaton, see~\cite[Example~1]{kaminskiFiniteMemoryAutomata1994}, but not by  a protocol. The intuitive reason for the negative result is that if neither Alice or Bob sees a repetition in their parts of the input string, then they should exchange all their letters to check for cross-part repetitions, which cannot be done in a constant number of messages -- 
    a detailed proof is given in \cref{sec:infinite-alphabets}. 
\end{myexample}

Which automaton model, if any, corresponds to protocols? As explained in the previous two examples, deterministic register automata are too weak, while nondeterministic register automata are too strong.
We conjecture (in Conjecture~\ref{conj:protocols-unambiguous}), that the winner is a seemingly  unexpected candidate, namely unambiguous register automata~\cite[Section 5]{colcombet2015unambiguity}. This is the special case of  nondeterministic register automata, in which for every input string there is at most one accepting run.
We discuss this conjecture in \cref{sec:infinite-alphabets}, and provide evidence in its favour. We start with an actual proof of one implication, namely:
\begin{align*}
\text{protocol} \quad \impliedby \quad \text{unambiguous automaton}.
\end{align*}
Contrary to  previous variants of this implication, the proof is non-trivial -- the usual construction does not work, because the automaton is nondeterministic. One  interesting phenomenon is that, in the case of infinite input alphabets, the interactive multi-round nature of the protocols becomes essential, and protocols cannot be reduced to one round, as was the case for finite input alphabets. In our proof of the implication $\impliedby$, we design a protocol where  the two parties  progressively eliminate the uncertainty about letters used in the run of the automaton, until the unique accepting run is identified or its existence disproved.
The proof uses a variant of the sunflower lemma.

Therefore,  the content of the conjecture is -- as in previous cases --  the other implication, namely that protocols can be simulated by unambiguous register automata. We provide evidence for this implication, using the recently developed theory of orbit-finite vector spaces~\cite{orbitFiniteVectorTheoretics}. We show that every function computed by a protocol can be computed by a weighted automaton with registers. This is almost like an unmabiguous automaton, except that some runs might have negative weights, and the weights always cancel out to give a final result that is either $0$ or $1$. In particular, the functions computed by protocols are computable, which is not a priori clear from the model. Along the way, we develop some new theory, in particular an orbit-finite generalisation of the Fliess Theorem. 

