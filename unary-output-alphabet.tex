% LTeX: language=en
\subsection{Unary output alphabet}
\label{sec:unary-output-alphabet}
\AP
In this section, we provide further evidence for
Conjectures~\ref{conj:protocol-regular-string-to-string}
and~\ref{conj:regular-continuous},
 by showing that they are true for output
alphabets with only one letter. We begin with the first conjecture.

\begin{theorem}\label{thm:unary-string-to-string}
  Conjecture~\ref{conj:protocol-regular-string-to-string} holds for string-to-string functions where the output alphabet has only one letter. In other words, for an output alphabet $\Gamma$ with one letter, protocols compute exactly the regular string-to-string functions. 
  
\end{theorem}

\begin{proof}
  In light of \cref{lem:from-regular-to-protocol}, the missing implication is from protocols to regular functions. We will prove a stronger result, namely that for unary output alphabets, protocols are equivalent to rational string-to-string functions, which are a special case of the regular string-to-string functions.   For general output alphabets, the special case is indeed spacial, i.e.~rational and regular are not the same, but the two classes coincide for output unary output alphabets (this is known, but it will also follow from the present theorem).

  Let us begin by defining the rational string-to-string  functions. One definition is that this is the special case of the rational relations mentioned in Example~\ref{ex:non-commutative-semirings}, in which the relations are functions (i.e.~for each input there is exactly one output). For the purposes of this proof, it will be more convenient to use an alternative definition based on lookahead automata, see for a proof of this defintion with the others~\cite[Theorem 14.1]{bojanczyk_automata_2025}. 

\begin{definition}[Lookahead automaton]\label{def:bimachine}
  A lookahead automaton consists of:
  \begin{enumerate}
    \item input and output alphabets $\Sigma$ and $\Gamma$;
    \item two deterministic automata: 
    \begin{enumerate}
      \item a lookahead automaton, with input alphabet $\Sigma$ and states $P$;
      \item a main automaton, with input alphabet $P$ and states $Q$.
      \omc{Is this a typo? Should it be "with input alphabet $\Sigma$"? According to the definition of lookahead automata in Eilenberg's book (Vol. A), both automata have input alphabet $\Sigma$ and one reads the input from right to left while the other reads from left to right, and output function depends on the states of both automata and the current input letter.}
    \end{enumerate}
    \item an output function of type $Q \times P \to \Gamma^*$. 
  \end{enumerate}
\end{definition}
We now define the function that is computed by a lookahead automaton, which has type  $\Sigma^* \to \Gamma^*$. The general idea is that the main automaton scans the input string from left to right, using the lookahead automaton for guidance, and in each step it adds some letters to  the  output string.  Suppose that the input string is $a_1 \cdots a_n$, and the main automaton has already processed a prefix $a_1 \cdots a_i$ for some $i \in \set{0,1,\ldots,n}$, with the current state of the main automaton  being $q_i$, and some prefix of the output string being already produced. Initially, when $i=0$, the state is the initial state of the main automaton, and the produced output is empty.  Let $p_i$ be the state of the lookahead automaton after reading the remaining part of the input $a_{i+1} \cdots a_n$; we call this the lookahead. Based on the pair $(q_i,p_i)$, the output function produces some part of the output string, which is appended to the already produced part. If the entire string has been consumed, i.e.~$i=n$, then the computation stops. Otherwise, the letter $a_{i+1}$ is consumed, the main automaton updates its state by using the lookeahead $p_i$ as an input letter, and the computation continues.  This completes the definition of the function computed by a lookahead automaton. 

As mentioned before,
lookahead automata compute exactly the rational functions. Therefore, to complete the proof of the theorem, we will show that if a function $f : \Sigma^* \to \Gamma^*$ is computed by a protocol, and the output alphabet $\Gamma$ has only one letter, then the function is also computed by a lookahead automaton. 

Since there is only one output letter, the monoids $(\Gamma^*,\cdot)$ and $(\Nat,+)$ are isomorphic, and therefore we can equivalently think of $f$ as a function with outputs in $\Nat$. In this view, the protocol is only allowed to use addition in $\Nat$, and it cannot use multiplication. 
We assume that the protocol has only one round, thanks to \cref{lemma:one-round-reduction-general}. Consider the strategy of Alice, which is a function 
\begin{align*}
\sigma_A : \Sigma^* \to \myunderbrace{Q_A \times \Nat^d}{elements of this set will be called \emph{configurations}}.
\end{align*}
In the proof, we order strings with respect to the configurations that they produce under Alice's strategy. We write $w' \le w$ if (a) the corresponding configurations have the same signal part from $Q_A$; and (b) the vectors from $\Nat^d$ are ordered so that  $w'$ has a smaller or equal vector than $w$, in the coordinatewise ordering on $\Nat^d$. The following lemma, which isolates a finite set of minimal strings, is a standard application of Dickson's lemma.

\begin{lemma}\label{lem:minimal-configurations}
  There is a finite set of strings $W \subseteq \Sigma^*$ such that each string is greater or equal to some string in $W$ with respect to the above ordering.
\end{lemma}
\begin{proof}
  We partition the strings with respect to the signal component, which gives us finitely many parts. In each part, the strings are ordered coordinatewise according to the vector from $\Nat^d$. By Dickson's lemma, there are finitely many minimal elements in each part, and therefore finitely many minimal elements overall.
\end{proof}

Let $W$ be the finite set which consists of the empty strings $\varepsilon$, plus the minimal strings from the above claim. Below define a lookahead automaton $\Aa$ that computes the function $f$, and which uses $W$ as the states of the main automaton. The automaton is designed to satisfy the following invariant:
\begin{align*}
\myunderbrace{\Aa_w}{lookahead automaton obtained from $\Aa$ by setting $w$ \\ to be the initial state of the main automaton}(v){} = f(wv).
\end{align*}
If we choose the empty string $\varepsilon$ as the initial state of the main automaton, then the invariant tells us that the automaton computes $f$, as needed to prove the theorem. It remains to define the transitions of the main automaton, the lookahead automaton, and the output function. Once these have been defined, the invariant will be proved by induction on the length of the remaining input string $v$.

Suppose that the main automaton is in state $w \in W$. If the remaining part of the input string is empty, which can be inferred by having an emptiness check in the lookahead automaton, then the automaton outputs $f(\varepsilon)$. Otherwise, the remaining input string has at least one letter, and it can be decomposed as $av$, where $a$ is its first letter.  By \cref{lem:minimal-configurations}, there is some $w' \in W$ with
\begin{align*}
w' \leq wa.
\end{align*}
The main automaton will consume the letter $a$, and change its state to  $w'$, with the remaining input string being $v$. For this state update, the only necessary lookahead is to know the first letter $a$. However, there will be some nontrivial lookahead used to compute the output. More specifically, when consuming the input letter $a$, in order to maintain the invariant, we  need to output the difference 
\begin{align}
  \label{eq:unary-difference-output}
\Aa_{w}(av) - \Aa_{w'}(v)  = f(wa v) -  f(w' v).
\end{align}
To compute this difference with lookahead, we will use the following lemma, which will be applied to $u' = w'$ and $u = wa$.



\begin{lemma}\label{lem:lookahead-regular-languages}
  Consider two strings $u' \leq u$ in $\Sigma^*$. Then
  \begin{enumerate}
    \item \label{it:lookahead-finite-set} The set $\setbuild{ f(uv) - f(u' v)}{$v \in \Sigma^* $}$ is finite and contains only non-negative integers.
    \item \label{it:lookahead-regular-language} For every $c$ in the above set, $\setbuild{ v \in \Sigma^*}{ $f(u v) - f(u' v) = c $}$ is a regular language.
  \end{enumerate}
\end{lemma}
\begin{proof}
  We begin with finiteness  from item~\ref{it:lookahead-finite-set}. Since the signals of Alice are the same in the configurations of $u$ and $u'$, it follows that the pairs of signals of Alice and Bob will be the same in the executions of the protocol on both $(u,v)$ and $(u',v)$. This means that the output in both cases will be obtained by taking some fixed number (which depends on $v$) and adding to it a number that appears in Alice's configuration after reading $u$ or $u'$. Since $u$ and $u'$ are fixed, it follows that difference 
  \begin{align*}
  f(uv) - f(u'v)
  \end{align*}
  is bounded by a constant independent of $v$, which only depends on Alice's configurations for $u$ and $u'$. This proves finiteness. The difference is also a non-negative, by the assumption that $u' \leq u$, which implies that the contribution of Alice is smaller or equal in $u'$ as compared to $u$.

  %  Fix some difference $c$. We will give a protocol (with Boolean outputs) that computes the language 
  % \begin{align*}
  % \setbuild{ v \in \Sigma^*}{ $f(u v) - f(u' v) = c $}.
  % \end{align*}
  % Since protocols with Boolean outputs compute exactly the regular languages by \cref{thm:boolean-domain}, this will prove the claim. In the new protocol that we are designing, the input string is $v$, and it is split into two parts $v = v_1 v_2$, one for Alice and one for Bob. Bob sends the signal from $Q_B$ that he would have sent for $v_2$ in the original protocol for $f$. 
  
  Let us now prove item~\ref{it:lookahead-regular-language} about regularity.
  Consider the original protocol for $f$. This is a protocol with output domain $(\Nat,+)$, which can be thought of as a special case of  the field $(\Rat,+, \times)$. In the special case multiplication is not used by the protocol, and only natural numbers are sent. By \cref{thm:field-domain} on protocols with field outputs, we know that the function $f$ is computed by a weighted automaton over $\Rat$. From this and standard closure properties of weighted automata, it follows that once we fix $u$ and $u'$,  the function 
  \begin{align*}
  v \quad \mapsto \quad f(uv) - f(u' v)
  \end{align*}
  is also computed by a weighted automaton over $\Rat$. By the previous item, this function has finite image. To establish regularity of the langauge in item~\ref{it:lookahead-regular-language} and thus conclude the proof of the lemma, we use the following result about weighted automata with finite image.
  \begin{claim}
    Let $\domain$ be a field, and consider a function $f : \Sigma^* \to \domain$ which is computed by a weighted automaton and has finite range. Then for every $c \in \domain$, the preimage $f^{-1}(c)$ is a regular language.
  \end{claim}
  \begin{proof}
    Define the \emph{support language} of a weighted automaton to be the set of input strings that are sent to zero. The inverse image $f^{-1}(c)$ is a support language, namely the support language of the weighted automaton $f-c$.  Support languages are closed under finite unions, by multiplying two weighted automata. Therefore, if $f$ has finite image, then both $f^{-1}(c)$ and its complement are support languages, since the complement is a finite union of support languages of the form $f^{-1}(c_1) \cup \cdots \cup f^{-1}(c_n)$. By~\cite[Theorem 3.1]{restivo1984cancellation}, if a language and its complement are support languages, then the language is regular.
  \end{proof}
\end{proof}

Thanks to the above lemma, when the automaton is in state $w$ and the remaining input string is $av$, it can use regular lookahead to compute the difference~\eqref{eq:unary-difference-output}, and output it. This difference is non-negative, and therefore it is a legitimate output. There are finiely many possible choices for $u$ and $u'$, and therefore all  the regular languages from item~\ref{it:lookahead-regular-language} in \cref{lem:lookahead-regular-languages} can be combined into a single lookahead automaton. This completes the construction of the lookahead automaton $\Aa$, and therefore the proof of the theorem.
\end{proof}

In the rest of this section, we use the above theorem to derive some further observations, and in particular to prove Conjecture~\ref{conj:regular-continuous} for unary output alphabets. The first observation is about protocols that use integers with addition and have non-negative outputs.

% As in the proof of the theorem, a string-to-string function with a
% unary output alphabet can be seen as a string-to-number function with outputs in $\Nat$. The following theorem states that considering string-to-number
% protocols (keeping only addition as operation on numbers) does not change the
% class of functions if the outputs are non-negative.

\begin{theorem}
  \label{thm:string-to-number-protocols-nat}
  Consider a protocol with output domain $(\Int,+)$ where all outputs are non-negative. Then the same function can be computed by a protocol with output domain $(\Nat,+)$.
\end{theorem}
\begin{proof}
  Let us assume without loss of generality that $f$ is computed by a one-round
  protocol.  We use the name \emph{configuration} for the message sent by alice, similarly to the proof of \cref{thm:unary-string-to-string}. The configuration consists of a signal, and several integers. We can improve the protocol so that:  (a) for each input with a split $w = w_1 w_2$ exactly one of the numbers in Alice's configuration is part of the  final output; and (b) if Alice's configuration for a string $w_1$ uses some integer, then  there is some $w_2$ where this integer contributes to the final output.  These assumptions can be ensured by a powerset
  construction on Alice's side.

  Let us prove the following intermediate claim: the integers in  Alice's configuration are
  uniformly bounded below. This is a simple corollary of the properties (a) and (b) below: if the integers would be arbitrarily large negative numbers, then the contribution of Bob for some fixed string $w_2$ would not be enough to offset them. 


  Thanks to the above claim, we can further improve the protocol as follows. Alice sends her original configuration, with the following change: if some numbers were negative, then they are truncated to zero, and the signal is adjusted so that it stores the negative numbers. This can be done in a finite signal space, due to the claim on lower bounds. Once Bob receives the message, he can the produce the output of the original protocol, by possibly using the signals to reconstruct the original integers.
\end{proof}

This theorem allows us to derive a characterisation of functions 
computed by weighted automata over $\Nat$ that have linear growth.

\begin{corollary}
  \label{cor:weighted-automata-nat-regular}
  Let $f : \Sigma^* \to \Rat$ be a function computed by a weighted automaton
  over  $\Rat$, which has linear growth (i.e.~the output number is at most linear in the input lenth), and such that all outputs are natural numbers. Then $f$ is a regular function, when viewed as a string-to-string function with a unary output alphabet.
\end{corollary}
\begin{proof}
  It is well-known that weighted automata over $\Rat$ computing integer values
  can be simulated by weighted automata over the semiring $\Int$: this is
  sometimes referred to as $\Rat$ being a Fatou extension of $\Int$
  \cite[p. 110]{BerstelReutenauer08}.
  Therefore, we can assume without loss of generality that $f$ is computed by
  a weighted automaton over $\Int$. Then, one can leverage a 
  result from \cite{Zpolyreg23} stating that weighted automata over $\Int$
  with linear growth can be computed as follows: first, a regular function $g : \Sigma^* \to
  \{a,b\}^*$ is computed, then each letter $a$ is mapped to $+1$ and each 
  letter $b$ is mapped to $-1$, and finally all values are summed up. 
  For a precise statement, see \cite[Proposition II.13, Theorem III.3]{Zpolyreg23}.
  Now, it is clear from the above description that $f$ can be computed by a protocol
  manipulating integer values, and combining them only using addition. By
  \cref{thm:string-to-number-protocols-nat}, $f$ can also be computed by a
  protocol manipulating natural numbers. Finally, by \cref{thm:unary-string-to-string},
  $f$ is a regular function.
\end{proof}

From the above, we conclude that Conjecture~\ref{conj:regular-continuous} holds for unary output alphabets.
\begin{corollary}
  \label{cor:regular-continuous-unary}
  Conjecture~\ref{conj:regular-continuous} holds for string-to-string functions where the output alphabet has only one letter.
\end{corollary}
\begin{proof}
  Let $f : \Sigma^* \to \Gamma^*$ be a function with a unary output alphabet which is field continuous. Compose this function with the weighted automaton $\Aa : \Gamma^* \to \Rat$ which computes the length of the output string. The result is a function that is subject to the assumptions of \cref{cor:weighted-automata-nat-regular}, and therefore it is a regular function. 
\end{proof}
Let us conclude this section with an example showing that
\cref{cor:weighted-automata-nat-regular} cannot be extended to weighted
automata over $\Int$ with arbitrary growth.

\begin{myexample}[Quadratic counterexample]\label{ex:quadratic-counterexample}
     We show  a function which: (a) is a linear combination of \mso  counting functions of arity two, with negative coefficients; (b) has only non-negative outputs; and (c) cannot be presented as linear combination with positive coefficients. The idea, which is based on~\cite[Example 2.1]{BerstelReutenauer08}, is to trivially ensure non-negativity by squaring. Take the function
\begin{align*}
w \in \set{a,b}^* 
\quad \mapsto \quad 
(\text{(number of $a$'s in $w$)} - \text{(number of $b$'s in $w$)})^2.
\end{align*}
This function clearly satisfies (a) and (b). As explained in \cite[p.3]{Zpolyreg23}, it also satisfies (c), since the inverse image of $0$ is not a regular language, as would be the case if only positive coefficients were used.
\end{myexample}
