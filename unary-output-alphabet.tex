% LTeX: language=en
\subsection{Unary output alphabet}
\label{sec:unary-output-alphabet}
\AP
In this section, we provide further evidence for
Conjectures~\ref{conj:protocol-regular-string-to-string}
and~\ref{conj:regular-continuous},
 by showing that they are true for output
alphabets with only one letter. 
To prove the conjectures, we will pass through rational functions, which are a fragment of the regular functions. When the output alphabet has only one letter, rational functions and regular functions coincide, which means that the results on rational functions are relevant in this case.

\subsubsection{Rational functions and monotone protocols}
In this section, we use a variant of the  protocols  to characterise exactly the rational string-to-string functions.  This will be done by applying a characterisation of the rational functions due to Sch\"utzenberger and Reutenauer~\cite{reutenauerSchutzenberger1991}, which happens to be ideally matched to our protocol model, subject to a monotonicity restriction. Let us begin by defining the relevant notions.

\paragraph*{Rational functions.} There are several ways of defining the rational string-to-string functions. For the results in this section, the particular choice of definition will not be important, since we will refer to an external result about rational functions. Nevertheless, for the reader's convenience we include a definition, which is based on weighted automata over the semiring of finite sets of words. 

 Consider a nondeterministic automaton with an input alphabet $\Sigma$, together with an output map 
\begin{align*}
\text{output} : 
\myunderbrace{(I + F + \Delta)}{disjoint union of initial states, final states, and transitions}
\to \Gamma^*.
\end{align*}
Using the output map,  we can associate to each accepting  run of the automaton an output string, which is obtained by concatenating the output strings associated with the initial state,  the transitions used in the run, and the  final state. This way, the automaton defines a relation between input and output strings, which maps an input string to the outputs of all possible accepting runs. Such a relation is called a  \emph{rational string-to-string relation}. A \emph{rational string-to-string function} is the special case where each input string is mapped to exactly one output string. 

\begin{myexample}
  The identity function is rational, and so is the function which deletes all $a$'s from the input string. Another example is the function which swaps the first and last letters, and leaves the rest of the input string unchanged. String reversal is not rational; also duplication is not rational.
\end{myexample}


\paragraph*{Monotone protocols.}
A protocol with string-to-string outputs is called \emph{monotone} if the output string is produced by concatenating two strings, the left one produced by Alice, and the right one produced by Bob. One can consider monotone protocols with one or more rounds. The reduction to one-round protocols from Lemma~\ref{lemma:one-round-reduction-general} also works in the presence of the monotone restriction, and therefore we will only talk about one-round monotone protocols. Such a protocol can be described more elementarily as follows. The two players have strategies 
\begin{align*}
    \sigma_A & : \Sigma^* \to Q_A \times (\Gamma^*)^{d},\\
        \sigma_B & : \Sigma^* \to Q_B \times (\Gamma^*)^{d},
\end{align*}
in which they send a signal as well as a tuple of $d$ strings over the output alphabet. Based on the signals received from both players, the output is produced by concatenating two of the output strings, one from Alice and one from Bob. This is formalised by  an output function of type
\begin{align*}
  \text{output} : Q_A \times Q_B \to \set{1,\ldots,d}.
\end{align*}
The output of the protocol is then defined as follows: we apply the output function to the signals produced by both players, which gives us an index $i \in \set{1,\ldots,d}$, and then the output string is obtained by concatenating the $i$-th string from Alice with the $i$-th string from Bob.

\paragraph*{Equivalence of the models.} We now show that the monotone protcols compute exactly the rational string-to-string functions. As it turns out, this equivalence was essentially already proved by Sch\"utzenberger and Reutenauer in~\cite{reutenauerSchutzenberger1991}, albeit in a different language. The corresponding characterisation is stated below.

\begin{theorem}
  \label{thm:monotone-protocols-rational}
  For a string-to-string function $f : \Sigma^* \to \Gamma^*$, the following are equivalent:
  \begin{enumerate}
    \item \label{item:monotone-protocol} $f$ is computed by a monotone protocol;
    \item \label{item:partial-functions} there is a finite family of partial string-to-string functions 
\begin{align*}
\set{\alpha_i,\beta_i  : \Sigma^* \to \Gamma^*}_{i \in I}
\end{align*}
such that the (total) function 
\begin{align*}
  (w_1,w_2) \quad \mapsto \quad f(w_1 w_2)
\end{align*}
is equal to  the union of partial functions
\begin{align*}
  \bigcup_{i \in I} (w_1,w_2) \mapsto \myunderbrace{\alpha_i(w_1) \cdot \beta_i(w_2)}{the concatenation is defined \\  only if both functions are defined}.
\end{align*}
    \item \label{item:rational-function} $f$ is a rational string-to-string function.
  \end{enumerate}
\end{theorem}
\begin{proof}
The equivalence of items \ref{item:partial-functions} and \ref{item:rational-function}, which is the essence of the theorem, was proved  by Sch\"utz-enberger and Reutenauer in~\cite[p. 674] {reutenauerSchutzenberger1991}. It remains to show the equivalence of items \ref{item:monotone-protocol} and \ref{item:partial-functions}, which is a simple unfolding of the definitions.

\begin{itemize}
  \item 
    \ref{item:partial-functions} $\implies$ \ref{item:monotone-protocol}. Suppose that $f$ satisfies item~\ref{item:partial-functions}. 
    As her signal, Alice says which of the functions $\alpha_i$ are defined on her part of the input, and sends all the corresponding outputs. Bob does the same on his side. Based on the signals, they can determine an index $i$ such that both $\alpha_i$ and $\beta_i$ are defined, and then they can concatenate the corresponding outputs to produce the final output. This shows that item~\ref{item:monotone-protocol} holds.
  \item
    \ref{item:monotone-protocol} $\implies$ \ref{item:partial-functions}. Suppose  that $f$ satisfies item~\ref{item:monotone-protocol}.
    Based on the monotone protocol from the assumption, we define the indexing set  $I$ to be  $Q_A \times Q_B$, i.e.~all possible combinations of signals of Alice and Bob. For each such pair of signals $(q_A,q_B) \in Q_A \times Q_B$, we define two partial functions. The first one  is defined on those strings $w_1$ for which Alice's signal is $q_A$, and in this case it produces the $i$-th string from Alice, where $i$ is obtained by applying the output function to $(q_A,q_B)$. The second one is defined similarly on Bob's side. It is easy to see that the conditions from item~\ref{item:partial-functions} are now satisfied.
\end{itemize}
\end{proof}

Before continuing, let us remark that a similar approach could be taken to characterise the subsequential functions, which are the subclass of rational functions that corresponds to deterministic automata. In this case, the corresponding restriction on the protocols is  monotonicity, plus the extra requirement  is that the output function does not depend on the signal sent by Bob, i.e.~the only signal information travels from left to right. Using a characterisation of subsequential functions from~\cite{choffrut1977}, one can show that such protocols compute exactly the subsequential functions. The details are left to the reader.


\subsubsection{Proofs of Conjectures~\ref{conj:protocol-regular-string-to-string}
and~\ref{conj:regular-continuous} for a unary output alphabet}
Using the above characterisation of rational functions, we can now prove Conjectures~\ref{conj:protocol-regular-string-to-string} and~\ref{conj:regular-continuous} for unary output alphabets. The first conjecture is an immediate corollary. 
\begin{theorem}\label{thm:unary-string-to-string}
  Conjecture~\ref{conj:protocol-regular-string-to-string} holds for string-to-string functions where the output alphabet has only one letter. In other words, for an output alphabet $\Gamma$ with one letter, protocols compute exactly the regular string-to-string functions. 
\end{theorem}
\begin{proof}
  When the output alphabet has only one letter, then: (a) rational string-to-string functions coincide with the regular string-to-string functions, which is a folklore result; and (b) monotone protocols coincide with general protocols, since there is no difference between concatenating two strings in different orders. Therefore, the equivalence from \cref{thm:monotone-protocols-rational} implies the theorem.
\end{proof}

In the rest of this section, we use the above theorem to derive some further observations, and in particular to prove Conjecture~\ref{conj:regular-continuous} for unary output alphabets. The first observation is about protocols that use integers with addition and have non-negative outputs.

% As in the proof of the theorem, a string-to-string function with a
% unary output alphabet can be seen as a string-to-number function with outputs in $\Nat$. The following theorem states that considering string-to-number
% protocols (keeping only addition as operation on numbers) does not change the
% class of functions if the outputs are non-negative.

\begin{theorem}
  \label{thm:string-to-number-protocols-nat}
  Consider a protocol with output domain $(\Int,+)$ where all outputs are non-negative. Then the same function can be computed by a protocol with output domain $(\Nat,+)$.
\end{theorem}
\begin{proof}
  Let us assume without loss of generality that $f$ is computed by a one-round
  protocol.  We use the name \emph{configuration} for the message sent by alice, similarly to the proof of \cref{thm:unary-string-to-string}. The configuration consists of a signal, and several integers. We can improve the protocol so that:  (a) for each input with a split $w = w_1 w_2$ exactly one of the numbers in Alice's configuration is part of the  final output; and (b) if Alice's configuration for a string $w_1$ uses some integer, then  there is some $w_2$ where this integer contributes to the final output.  These assumptions can be ensured by a powerset
  construction on Alice's side.

  Let us prove the following intermediate claim: the integers in  Alice's configuration are
  uniformly bounded below. This is a simple corollary of the properties (a) and (b) below: if the integers would be arbitrarily large negative numbers, then the contribution of Bob for some fixed string $w_2$ would not be enough to offset them. 


  Thanks to the above claim, we can further improve the protocol as follows. Alice sends her original configuration, with the following change: if some numbers were negative, then they are truncated to zero, and the signal is adjusted so that it stores the negative numbers. This can be done in a finite signal space, due to the claim on lower bounds. Once Bob receives the message, he can the produce the output of the original protocol, by possibly using the signals to reconstruct the original integers.
\end{proof}

This theorem allows us to derive a characterisation of functions 
computed by weighted automata over $\Nat$ that have linear growth.

\begin{corollary}
  \label{cor:weighted-automata-nat-regular}
  Let $f : \Sigma^* \to \Rat$ be a function computed by a weighted automaton
  over  $\Rat$, which has linear growth (i.e.~the output number is at most linear in the input length), and such that all outputs are natural numbers. Then $f$ is a regular function, when viewed as a string-to-string function with a unary output alphabet.
\end{corollary}
\begin{proof}
  It is well-known that weighted automata over $\Rat$ computing integer values
  can be simulated by weighted automata over the semiring $\Int$: this is
  sometimes referred to as $\Rat$ being a Fatou extension of $\Int$
  \cite[p. 110]{BerstelReutenauer08}.
  Therefore, we can assume without loss of generality that $f$ is computed by
  a weighted automaton over $\Int$. Then, one can leverage a 
  result from \cite{Zpolyreg23} stating that weighted automata over $\Int$
  with linear growth can be computed as follows: first, a regular function $g : \Sigma^* \to
  \{a,b\}^*$ is computed, then each letter $a$ is mapped to $+1$ and each 
  letter $b$ is mapped to $-1$, and finally all values are summed up. 
  For a precise statement, see \cite[Proposition II.13, Theorem III.3]{Zpolyreg23}.
  Now, it is clear from the above description that $f$ can be computed by a protocol
  manipulating integer values, and combining them only using addition. By
  \cref{thm:string-to-number-protocols-nat}, $f$ can also be computed by a
  protocol manipulating natural numbers. Finally, by \cref{thm:unary-string-to-string},
  $f$ is a regular function.
\end{proof}

From the above, we conclude that Conjecture~\ref{conj:regular-continuous} holds for unary output alphabets.
\begin{corollary}
  \label{cor:regular-continuous-unary}
  Conjecture~\ref{conj:regular-continuous} holds for string-to-string functions where the output alphabet has only one letter.
\end{corollary}
\begin{proof}
  Let $f : \Sigma^* \to \Gamma^*$ be a function with a unary output alphabet which is field continuous. Compose this function with the weighted automaton $\Aa : \Gamma^* \to \Rat$ which computes the length of the output string. The result is a function that is subject to the assumptions of \cref{cor:weighted-automata-nat-regular}, and therefore it is a regular function. 
\end{proof}
Let us conclude this section with an example showing that
\cref{cor:weighted-automata-nat-regular} cannot be extended to weighted
automata over $\Int$ with arbitrary growth.

\begin{myexample}[Quadratic counterexample]\label{ex:quadratic-counterexample}
     We show  a function which: (a) is a linear combination of \mso  counting functions of arity two, with negative coefficients; (b) has only non-negative outputs; and (c) cannot be presented as linear combination with positive coefficients. The idea, which is based on~\cite[Example 2.1]{BerstelReutenauer08}, is to trivially ensure non-negativity by squaring. Take the function
\begin{align*}
w \in \set{a,b}^* 
\quad \mapsto \quad 
(\text{(number of $a$'s in $w$)} - \text{(number of $b$'s in $w$)})^2.
\end{align*}
This function clearly satisfies (a) and (b). As explained in \cite[p.3]{Zpolyreg23}, it also satisfies (c), since the inverse image of $0$ is not a regular language, as would be the case if only positive coefficients were used.
\end{myexample}
