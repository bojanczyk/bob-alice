\subsection{Unary output alphabet}
\label{sec:unary-output-alphabet}

In this section, we provide further evidence for
Conjectures~\ref{conj:protocol-regular-string-to-string}
and~\ref{conj:regular-continuous}, by showing that they are true for output
alphabets with only one letter. From a technical point of view, this is the
most involved result in the paper, since our proof uses a refined analysis of
the expressive power of weighted automata that output natural numbers of linear
size.

\begin{theorem}\label{thm:unary-string-to-string}
    The following conditions are equivalent for  a string-to-string function where  the output alphabet  has only one letter:
    \begin{enumerate}
        \item computed by a protocol;
        \item \label{it:unary-weighted-continuous} field continuous;
        \item \label{it:unary-regular} regular.
    \end{enumerate}
\end{theorem}

In light of Lemmas \ref{lem:from-regular-to-protocol} and
\ref{lem:postcomposition-weighted-automaton}, the only missing implication is
\ref{it:unary-weighted-continuous}~$\Rightarrow$~\ref{it:unary-regular},
that is the content of \cref{lem:nat-protocols-regular} below.


\begin{lemma}
  \label{lem:nat-protocols-regular}
  Let $f : \Sigma^* \to \{a\}^*$ be a function computed by a protocol
  manipulating natural numbers. Then $f$ is a regular function.
\end{lemma}

Let us first remark that under the assumption that the output is unary,
the class of "rational" and "linear regular functions" coincide.

\begin{lemma}
  \label{lem:unary-linear-regular-rational}
  Let $f : \Sigma^* \to \{a\}^*$ be a function. The following conditions are
  equivalent:
  \begin{enumerate}
    \item \label{it:unary-rational}
      $f$ is a rational function;
    \item \label{it:unary-linear-regular}
        $f$ is a linear regular function.
  \end{enumerate}
\end{lemma}
\begin{proof}
  The implication \ref{it:unary-rational}~$\Rightarrow$~\ref{it:unary-linear-regular}
  is immediate  and holds even without the assumption on the 
  unary output from \cref{fig:transducer-classes}.

  For the converse implication, assume that $f$ is rational. Then it is
  computed by a two-way transducer with outputs. However, this transduction can
  be decomposed into a two step process: first, a rational function computes
  the crossing sequences of the transducer on every letter of the input, and
  then, a two-way transducer that simply follows these crossing sequences to
  produce the output in the correct order. Since the order of the output does
  not matter in the unary case, the second step can be performed in a
  block-wise fashion, producing all outputs corresponding to a letter
  immediately after reading it. This second step is therefore also a rational
  function, and since those are closed under composition, we conclude that $f$ is
  a rational function.
\end{proof}

Let us consider a "protocol" computing a function $f : \Sigma^* \to \{a\}^*$.
Recall that one can assume that the protocol is one round
(\cref{lemma:one-round-reduction-general}). Let us write $\sigma_A : \Sigma^*
\to Q_A \times \domain^k$ for the strategy of Alice, $\sigma_B : \Sigma^*
\times Q_A \to Q_B \times \domain^k$ for the strategy of Bob, and $\theta : Q_A
\times Q_B \to (\domain^{2k} \to \domain)$ for the combining function, that can
only use concatenation of registers. We can place a quasi-order on $Q_A \times
\domain^k$, by saying that $(q, \vec{r}) \leq (q', \vec{r}')$ if $q = q'$ and
for each $i \in \{1, \ldots, k\}$ we have $|r_i|\leq |r_i'|$. This quasi-order
on $Q_A \times \domain^k$ can be lifted to a quasi-order on strings in
$\Sigma^*$, by saying that $u \leq v$ if $\sigma_A(u) \leq \sigma_A(v)$. A key
property of this ordering is the following:

\begin{lemma}
  \label{lemma:order-monotonicity-unary-output}
  Let $u, v \in \Sigma^*$ be such that $u \leq v$. Then for every $w \in
  \Sigma^*$, we have $|f(uw)| \leq |f(vw)|$. Furthermore, the function 
  $\Delta_{u,v} : w \mapsto |f(vw)| - |f(uw)|$ is a bounded function, and for 
  every $c \in \Nat$, the set $\{ w \in \Sigma^* : \Delta_{u,v}(w) = c\}$ is
  a regular language.
\end{lemma}
\begin{proof}
  Assume that $u \leq v$, and fix some $w \in \Sigma^*$.
  Let $q \in Q_A$ be the state that Alice sends to Bob after reading $u$.
  It is the same state after reading $v$. From the point of view of 
  Bob, the two strings behave identically. Now, since the combining function
  can only use concatenation of registers, and since the registers produced by
  Bob on the split $(u, w)$ are the same as those produced on the split
  $(v, w)$, the result follows by monotonicity of concatenation with respect to
  length. Note that the difference in lengths is bounded by the difference 
  between the lengths of the registers after Alice's turn, which does not 
  depend on $w$, proving the boundedness.

  Finally, the set $\{ w \in \Sigma^* : \Delta_{u,v}(w) = c\}$ is regular because it
  can be computed by a Boolean Alice-Bob protocol: Alice simulates the original protocol
  when prepending $u$ and $v$ to its input, sends the difference of the lengths 
  of its registers (that is now a finite message, since the difference is bounded) to Bob,
  who can then check whether the total difference is $c$.
  Because of \cref{thm:boolean-domain}, we conclude that the language is in fact regular.
\end{proof}

The second key property of the ordering is the following: it is in fact a
""well-quasi-order"", meaning that for any infinite sequence $(q_i,
\vec{r}_i)_{i \in \Nat}$, there are two indices $i < j$ such that $(q_i,
\vec{r}_i) \leq (q_j, \vec{r}_j)$. 

\begin{lemma}
  \label{lemma:wqo-unary-output}
  The quasi-order on $\Sigma^*$ defined above is a well-quasi-order.
\end{lemma}
\begin{proof}
  Because the order only compares words with respect to their image by
  $\sigma_A$, it is enough to show that the quasi-order on $Q_A \times
  \domain^k$ is a well-quasi-order.
  Since $Q_A$ is finite, it is enough to show that for each $q \in Q_A$,
  the quasi-order on $\{q\} \times \domain^k$ is a well-quasi-order.
  This follows from Dickson's lemma, since $\domain = \{a\}^*$ is isomorphic
  to $\Nat$ with addition, and since $\Nat^k$ with the product ordering is a
  well-quasi-order by Dickson's lemma.
\end{proof}

From the above two lemmas, we can conclude the proof of
\cref{lem:nat-protocols-regular}. 

\begin{proof}
  We claim that there exists a finite set $L$ of words $u_1, \ldots, u_n \in
  \Sigma^*$, closed under taking prefixes, and such that for every $u \in L$
  and every letter $a \in \Sigma$, either $ua \in L$, or there is some $u_i \in
  L$ such that $u_i \leq ua$. 
  Such a finite set $L$ exists by \cref{lemma:wqo-unary-output}, since one can
  extract a finite set of minimal elements for the quasi-order, and close it
  under prefixes. 

  We can now produce a left-to-right automaton that computes $f$ using regular
  lookaheads as follows. The states of the automaton are the words in $L$.
  The final output of a state $u_i \in L$ is $f(u_i)$.
  The transition from a state $u_i$ on a letter $a$ is defined as follows:
  \begin{itemize}
    \item if $u_i a \in L$, then the transition goes to state $u_i a$;
    \item otherwise, there is some $u_j \in L$ such that $u_j \leq u_i a$,
      and the transition goes to state $u_j$ (this is a choice made uniformly).
  \end{itemize}
  The lookahead for the transition from $u_i$ on $a$ is the regular language
  that tells the precise difference in size between $f(u_i a w)$ and $f(u_j w)$. By
  \cref{lemma:order-monotonicity-unary-output}, this delay is bounded so there 
  are finitely many possibilities, and the precise difference can be checked by a
  regular property on $w$. The automaton outputs this difference on the
  transition.

  An immediate induction proves that this automaton with regular lookaheads
  computes the same function as $f$, and it is a standard result that 
  regular functions are closed under regular lookaheads,
  concluding the proof.
\end{proof}


Let us now use \cref{lem:nat-protocols-regular} to prove a result on
string-to-number functions. Remark that a string-to-string function with a
unary output alphabet can be seen as a string-to-number function, by mapping
the string $a^n$ to the number $n$. Concatenation becomes addition in this
setting. The following theorem states that considering string-to-number
protocols (keeping only addition as operation on numbers) does not change the
class of functions if the outputs are non-negative.

\begin{theorem}
  \label{thm:string-to-number-protocols-nat}
  Let $f : \Sigma^* \to \Nat$ be a function computed by a protocol
  manipulating integers. Then, $f$ is also computed by a protocol
  manipulating natural numbers.
\end{theorem}
\begin{proof}
  Let us assume without loss of generality that $f$ is computed by a one-round
  protocol. Furthermore, up to normalizing the protocol, we can assume that only one
  register of Alice is used in the final computation, and that all registers of
  Alice can be used in some computation. This can be ensured by a powerset
  construction on Alice's side.

  Let us prove the following intermediate claim: the registers of Alice are
  uniformly bounded below. Assuming the contrary, there is a sequence of inputs
  $(u_i)_{i \in \Nat}$ such that the value of some register $r$ of Alice after
  reading $u_i$ tends to $-\infty$ as $i$ tends to infinity. Since there are
  finitely many states of Alice, we can assume without loss of generality that
  the state of Alice after reading $u_i$ is some fixed state $q$ for all $i$.
  Now, there is a fixed word $v$ such that when Bob receives state $q$ from
  Alice and reads $v$, the output of the protocol is the sum of register $r$ of
  Alice and some value computed by Bob. Because $r$ tends to $-\infty$ on the
  sequence $(u_i)_{i \in \Nat}$, the output of the protocol on inputs $u_i v$
  is negative for sufficiently large $i$, which is absurd.


  Hence, one can define a new protocol computing $f$ as follows: Alice
  computes as before, but truncates all registers to zero if they are
  negative. As state, she sends to Bob her state together with the content of
  the registers that were truncated, which is a finite information since we
  have proved that the registers are uniformly bounded below. Bob can then
  simulate the original protocol, if he wishes to use a truncated register,
  he directly substracts the value from his own output. The result of Bob
  remains non-negative, since the original protocol computed a non-negative
  output.
\end{proof}

This theorem allows us to derive a neat characterisation of functions 
computed by weighted automata over $\Nat$ that have linear growth.

\begin{corollary}
  \label{cor:weighted-automata-nat-regular}
  Let $f : \Sigma^* \to \Nat$ be a function computed by a weighted automaton
  over the semiring $\Rat$, such that $f$ has linear growth. Then, $f$ is a regular function.
\end{corollary}
\begin{proof}
  It is well-known that weighted automata over $\Rat$ computing integer values
  can be simulated by weighted automata over the semiring $\Int$: this is
  sometimes referred to as $\Rat$ being a "fatou extension" of $\Int$
  \cite[p. 110]{BerstelReutenauer08}.
  Therefore, we can assume without loss of generality that $f$ is computed by
  a weighted automaton over $\Int$. Then, one can leverage a 
  result from \cite{Zpolyreg23} stating that weighted automata over $\Int$
  with linear growth can be computed as follows: first, a regular function $g : \Sigma^* \to
  \{a,b\}^*$ is computed, then each letter $a$ is mapped to $+1$ and each 
  letter $b$ is mapped to $-1$, and finally all values are summed up. 
  For a precise statement, see \cite[Proposition II.13, Theorem III.3]{Zpolyreg23}.

  Now, it is clear from the above description that $f$ can be computed by a protocol
  manipulating integer values, and combining them only using addition. By
  \cref{thm:string-to-number-protocols-nat}, $f$ can also be computed by a
  protocol manipulating natural numbers. Finally, by \cref{thm:unary-string-to-string},
  $f$ is a regular function.
\end{proof}

Let us conclude this section with an example showing that
\cref{cor:weighted-automata-nat-regular} cannot be extended to weighted
automata over $\Int$ with arbitrary growth.

\begin{myexample}[Quadratic counterexample]\label{ex:quadratic-counterexample}
     We show  a function which: (a) is a linear combination of \mso  counting functions of arity two, with negative coefficients; (b) has only non-negative outputs; and (c) cannot be presented as linear combination with positive coefficients. The idea, which is based on~\cite[Example 2.1]{BerstelReutenauer08}, is to trivially ensure non-negativity by squaring. Take the function
\begin{align*}
w \in \set{a,b}^* 
\quad \mapsto \quad 
(\text{(number of $a$'s in $w$)} - \text{(number of $b$'s in $w$)})^2.
\end{align*}
This function clearly satisfies (a) and (b). As explained in \cite[p.3]{Zpolyreg23}, it also satisfies (c), since the inverse image of $0$ is not a regular language, as would be the case if only positive coefficients were used.
\end{myexample}
